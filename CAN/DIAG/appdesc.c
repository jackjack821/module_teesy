/* -----------------------------------------------------------------------------
  Filename:    appdesc.c
  Description: Implementation example for the proper usage with CANdesc.
                
                Manufacturer: BAIC
                EcuDocFile:   D:\HVACProject\Geely\KC_2\Gney\Geely_KC-2_009.cdd
                Variant:      CommonDiagnostics

  Generated by CANdelaGen, Thu Jul 07 18:05:12 2016
 
 ----------------------------------------------------------------------------- */
/* -----------------------------------------------------------------------------
  C O P Y R I G H T
 -------------------------------------------------------------------------------
  Copyright (c) 2001-2012 by Vector Informatik GmbH. All rights reserved.
 
  This software is copyright protected and proprietary to Vector Informatik 
  GmbH.
  
  Vector Informatik GmbH grants to you only those rights as set out in the 
  license conditions.
  
  All other rights remain with Vector Informatik GmbH.
 -------------------------------------------------------------------------------
 ----------------------------------------------------------------------------- */

/* -----------------------------------------------------------------------------
    &&&~ History
 ----------------------------------------------------------------------------- */

/* ----------------------------------------------------------------------------
  Please note, that the demo and example programs only show special aspects of 
  the software. With regard to the fact that these programs are meant for 
  demonstration purposes only, Vector Informatik´s liability shall be expressly 
  excluded in cases of ordinary negligence, to the extent admissible by law or 
  statute.
  ---------------------------------------------------------------------------- */

/* 
------------------------------------------------------------------------------------------------------------------------
                                             A U T H O R   I D E N T I T Y                                              
------------------------------------------------------------------------------------------------------------------------
Initials   Name                  Company                                                                                
---------- --------------------- ---------------------------------------------------------------------------------------
Ktw        Katrin Thurow         Vector Informatik GmbH                                                                 
Mhe        Matthias Heil         Vector Informatik GmbH                                                                 
Sa         Mishel Shishmanyan    Vector Informatik GmbH                                                                 
------------------------------------------------------------------------------------------------------------------------
                                            R E V I S I O N   H I S T O R Y                                             
------------------------------------------------------------------------------------------------------------------------
Date       Version  Author Modification type Issue Id      Affects                        Description                    
---------- -------- ------ ----------------- ------------- ------------------------------ -------------------------------
2009-08-11 05.07.18
                    Ktw    Added             ESCAN00036442 BAIC(UDS)                      Support for OEM BAIC           
                    Sa     Fixed             ESCAN00036995 All                            Compile warning on redeclaration of function DescGetBuffer
                    Sa     Fixed             ESCAN00036138 All                            Compiler warning on redundant declaration of DescGetBuffer
                    Sa     Modified          ESCAN00036996 All                            Switching between ANSI C and hardware optimized bit-type
                    Sa     Modified          ESCAN00037096 All                            Undo ESCAN00036465             
2009-08-31 05.07.19
                    -      -                 -             -                              No relevant changes available in this version.
2009-10-14 05.07.20
                    -      -                 -             -                              No relevant changes available in this version.
2009-11-17 05.07.21
                    Sa     Fixed             ESCAN00039237 All                            Compiler Warning: possible redundant expression / useless assignment
                    Sa     Modified          ESCAN00040135 All                            CanChannelIdentityAssignment is generated in RAM section
2010-02-02 05.07.22
                    -      -                 -             -                              No relevant changes available in this version.
2010-02-12 05.07.23
                    -      -                 -             -                              No relevant changes available in this version.
2010-05-12 05.07.24
                    Sa     Fixed             ESCAN00042963 All                            DescCopyToCan API does not support CAN message buffers located in the gpage
2010-05-31 05.07.25
                    Sa     Fixed             ESCAN00041576 All                            Compiler warning for constant expression in DescDispatcher
                    Sa     Fixed             ESCAN00043240 All                            Compiler error for missing data types DescDynDidMemBlockAddress and DescDynDidMemBlockSize
2010-07-16 05.07.26
                    Sa     Fixed             ESCAN00037465 UDS                            Compiler warning: parameter "pMsgContext" not used
                    Sa     Fixed             ESCAN00044189 UDS                            Valid service 0x28 request rejected with negative response
                    Sa     Fixed             ESCAN00044049 UDS                            Compiler warning: condition is always false
                    Sa     Fixed             ESCAN00044050 All                            Compiler warning: condition is always false
                    Sa     Fixed             ESCAN00044197 All                            Not all buffers used in DANIS can be located in far RAM
                    Sa     Added             ESCAN00044127 All                            Support for DANIS adapter specific available buffer size information to the application
2010-08-10 05.07.27
                    Sa     Fixed             ESCAN00044371 All                            v_inc.h is not included in the generated DANIS adapter template
                    Sa     Fixed             ESCAN00044528 All                            Compile errors in DanisIsoTp communication adapter
2010-10-14 05.07.28
                    Ktw    Fixed             ESCAN00045932 All                            Compile error on each usage of DescInterruptDisable/-Restore internal API
2010-10-08 05.07.29
                    Mhe    Fixed             ESCAN00046410 All                            After ECU reset the diagnostic response is not transmitted after the function DescSendPosRespFBL has been called
2010-12-18 05.07.30
                    Sa     Fixed             ESCAN00047355 All                            Memory mapping of FAR buffer support use incomplete description for paged memory µC
                    Ktw    Added             ESCAN00047741 All                            Adapt CANdesc TMS320 support for GENy enabled CANdriver
2011-01-04 05.07.31
                    Ktw    Fixed             ESCAN00047884 All                            ROM data used as function parameter
2011-01-21 05.07.32
                    Ktw    Added             ESCAN00048157 All                            Add Danis adapter for LinTp    
2011-03-07 05.07.33
                    -      -                 -             -                              No relevant changes available in this version.
2011-03-28 05.07.34
                    Sa     Fixed             ESCAN00049396 UDS                            No positive response sent if SPRMIB=TRUE and API DescForceRcrRpResponse is used
                    Sa     Modified          ESCAN00047821 All                            Missing protection of undefined V_MEMRAM3_FAR
                    Sa     Modified          ESCAN00048636 All                            Error message references non-existent file "ApplDesc.h"
2011-05-13 05.07.35
                    Sa     Fixed             ESCAN00050204 UDS                            CANdesc does not reject requested service 0x2C 0x02 with ALFID==0x00
2011-05-31 05.07.36
                    Ktw    Fixed             ESCAN00051088 UDS                            Service 0x2A 0x04 ends up with endless RCR-RP responses on asynchronously read periodic DIDs
                    Ktw    Added             ESCAN00051315 UDS                            API DescGetCurrentBusInfo should be usable for periodic transmission 
2011-09-14 05.07.37
                    -      -                 -             -                              No relevant changes available in this version.
2011-10-26 05.07.38
                    -      -                 -             -                              No relevant changes available in this version.
2012-01-16 05.07.39
                    -      -                 -             -                              No relevant changes available in this version.
2012-02-02 05.07.40
                    -      -                 -             -                              No relevant changes available in this version.
2012-06-05 05.07.41
                    -      -                 -             -                              No relevant changes available in this version.
2012-06-19 05.07.42
                    -      -                 -             -                              No relevant changes available in this version.
2012-06-19 05.07.43
                    -      -                 -             -                              No relevant changes available in this version.
2012-10-22 05.07.44
                    Ktw    Fixed             ESCAN00062276 All                            Enforce non-static request length for the OBD services
                    Ktw    Modified          ESCAN00062366 All                            CANDesc on multiple channels: Support more than 4 channels
------------------------------------------------------------------------------------------------------------------------
 */


/* -----------------------------------------------------------------------------
    &&&~ Includes
 ----------------------------------------------------------------------------- */
//#include "Rte_Diag.h" 
#include "general.h"

//#include "CANApp.h"
#define DiagRTE

#ifndef DiagRTE
#include "Rte_CCP.h"
#include "CCP_def.h"
#include "App_Boot.h"
#include "Diag_Cfg.h"
#include "Ccp.h"
#include "Ccp_cfg.h"

#include "desc.h"
#include "appdesc.h"
#include "Diag_Cfg.h"

#else
#include "CanApp.h"
#include "Rte_internal.h"
#include "DTC_Cfg.h"
#include "LinApp.h"
#include "EED.h"
#include "desc.h"
#include "appdesc.h"
#include "Diag_Cfg.h"
#include "App_Boot.h"
#include "SBC.h"
//#include "RFA.h"
#include "DTC.h"
//#include "OAT.h"
//#include "EVAP.h"
//#include "AQS.h"
#include "POW.h"
#include "Cannmapp.h"
#include "Vict.h"
#endif

/* Physical layer specific API */
#include "v_inc.h"
/* Check if CCL is available and take into account its configuration */
#if defined (VGEN_ENABLE_CCL)
# include "ccl_cfg.h"
#endif

/* Check if CCLcom is available and take into account its configuration */
#if defined (VGEN_ENABLE_CCLCOM)
# include "cclcom_cfg.h"
#endif

/* Make all CANdesc specific typedefs available */
#include "desc.h"
/* Include the implementation prototypes for prototype checks */
#include "appdesc.h"

#define Ascii2Hex(data)  (data < 10)? (48 + data) : (55 + data)

#define PassWord_1 0x2C
#define PassWord_2 0xAC
#define PassWord_3 0x27
#define PassWord_4 0xA7
uint8 Seed[4];
/* -----------------------------------------------------------------------------
    &&&~ Preprocessor constants (defines)
 ----------------------------------------------------------------------------- */

#define kDescEcuCryptoKey                                            0x12345678


#define Diag_GeelySparePartNumber_Len   (8U)
#define Diag_SystemSupplier_Len         (6U)

static uint8 Diag_SystemSupplier[Diag_SystemSupplier_Len]={"752003"};
static const uint8 Geely_u8DateTable[31] = {'1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','G','H','J','K','L','M','N','P','R','S','T','V','W','X','Y','Z'};


static uint16 Diag_u16IOCtrFreeTimer[Diag_nu16CtrFreeMax];
static uint8 Diag_u8IOCtrFlag[Diag_nu16CtrFreeMax];

/* -----------------------------------------------------------------------------
    &&&~ Function prototypes
 ----------------------------------------------------------------------------- */

static vuint32 SecM_ComputeKey(void);
static void SecM_Serializer(DescMsg tgtPtr, vuint32 data);
 uint8 Hex2Bcd(uint8 *Tempdata);
 uint8 Bcd2Hex(uint8 *Tempdata);
 uint8 CheckIfBcd(uint8 *Tempdata); 

static void Diag_vSaveSecureTimer(void);
static void Diag_vHardReset(void);
static void Diag_vSoftReset(void);
static void Diag_vRandSeed(void);
static vuint8 ApplDescAppToDiagTempFormat(vuint16 u16AppTemp);
static void Diag_vSelfTestCheck(void);
static void Diag_vIOCtrFreeCheck(void);
static void Diag_vActiveCheck(void);
static void Diag_vFuntionCfg(void);
static void Diag_vPutValue2Rte(void);
static void Diag_vPendingResCkeck(void);

/* -----------------------------------------------------------------------------
    &&&~ RAM definitions
 ----------------------------------------------------------------------------- */

/* 64Bit seed stored for the later key compare */
static uint32 g_applDescSeedX;
static uint32 g_applDescSeedY;
static uint8 Diag_biHardReset;
static uint8 Diag_biSoftReset;
static uint32 SeedCounter1;
static uint32 SeedCounter2;
static uint16 Diag_u16PendingResTimer = 0U;
static uint8 Diag_boPendingResReq=False;
static uint8 Diag_u8LastSessionControl = 0xFF;
static uint8 Diag_u8ResetDelay = 1;/*100ms*/
static uint8 Diag_SelfTestRoutineTimer;
static uint8 Diag_boSelfTestReq;
static uint8 DIAG_au8Array[DIAG_nu8Max];
static uint8 Diag_u8ClearDTCPeingReq;


static void Diag_vSaveSecureTimer(void)
{
    uint16 u16DataLen;
    uint8 u8Result;
    /*save the Security Timer accroding to the Geely requirement*/
    if(Diag_u8Group1SecureNrOfAttempts !=DescGetAttemptCounterValue(DESC_CONTEXT_PARAM_ONLY))
    {
            Diag_u8Group1SecureNrOfAttempts =DescGetAttemptCounterValue(DESC_CONTEXT_PARAM_ONLY);
            u16DataLen = sizeof(Diag_stLayout)-2; /*not include the check sum*/

            u8Result = Rte_Call_IoHwEep_IoHwEedProto_WriteEep_DiagData_EedWrite((uint8*)&Diag_stLayout,u16DataLen);//Rte_Call_Diag_WriteEep_DiagData_EedWrite(&Diag_u8Group1VariableConst,u16DataLen);           
	
            if(u8Result != 0) /*not successful*/
            {
            /* Received data is in range process further. */
            /* Contains no response data */
            }
    }
}
static void Diag_vHardReset(void)
{
    if(Diag_biHardReset == True)
    {
        if(DIAG_au8Array[DIAG_nu8ResetFlag] == False)
        {
        	//SBC_vNormalStandby(); 
            DIAG_au8Array[DIAG_nu8ResetFlag] = True; 
        }
        
        if(Diag_u8ResetDelay!=0)
        {
            Diag_u8ResetDelay--;
        }
        else
        {
	        MCU_vResetCtrl_Reset();//HAL_vMcuReset();/*160506*/
            while(1);
        }
    }
}
static void Diag_vSoftReset(void)
{
    if(Diag_biSoftReset == True)
    {
        if(DIAG_au8Array[DIAG_nu8ResetFlag] == False)
        {
        	//SBC_vNormalStandby();  
            DIAG_au8Array[DIAG_nu8ResetFlag] = True; 
        }
        
        if(Diag_u8ResetDelay!=0)
        {
            Diag_u8ResetDelay--;
        }
        else
        {
    	    MCU_vResetCtrl_Reset();//HAL_vMcuReset();/*160506*/
        }
    }
}
static void Diag_vRandSeed(void)
{
    SeedCounter1++;
    SeedCounter2--;    
}

static void Diag_vSessionCheck(void)
{
    //uint32 u32Command =0x01A20000;/*Release Warning,161024*/
    uint8  u8CurrentDiagSession = kDescStateSessionDefault,u8i;
    
    u8CurrentDiagSession = DescGetStateSession();
    
     if((Diag_u8LastSessionControl!=u8CurrentDiagSession)&&(u8CurrentDiagSession == kDescStateSessionDefault))  
     {
        /*Enter the lock state*/
	    DescSetStateSecurityAccess(kDescStateSecurityAccessLocked);/*Add by LT,20160524,accroding to the Geely Spec 3.2,page 30*/

        /*For all the $2F, return to reset control*/     
        Diag_MacForceIOControl_ForceCtrl(0);  
        Diag_RfaForceIOControl_ForceCtrl(0); 
        Diag_AirdForceIOControl_ForceCtrl(0); 
        Diag_BctlForceIOControl_ForceCtrl(0); 
        Diag_AcccForceIOControl_ForceCtrl(0); 
        Diag_IonForceIOControl_ForceCtrl(0);
        Diag_DimForceIOControl_ForceCtrl(0);
        Diag_LcdForceIOControl_ForceCtrl(0);
        Diag_AqsForceIOControl_ForceCtrl(0);
        Diag_ReDefForceIOControl_ForceCtrl(0);
        
        
        for(u8i=0;u8i<Diag_nu16CtrFreeMax;u8i++)
        {        
            Diag_u16IOCtrFreeTimer[u8i]=0u;
        }

        for(u8i=0;u8i<Diag_nu16CtrFreeMax;u8i++)
        {        
            Diag_u8IOCtrFlag[u8i]=False;
        }

        /*For 28 communication*/
        DIAG_au8Array[DIAG_nu8AppRxDisable] = False;

        /*For 85 DTC Enable*/
        Diag_DtcForceIOControl_ForceCtrl(0); 
        
     }
     else if(u8CurrentDiagSession == kDescStateSessionExtendedDiagnostic)
     {
        Diag_vIOCtrFreeCheck();
     }

     Diag_u8LastSessionControl = u8CurrentDiagSession;
}


static void Diag_vIOCtrFreeCheck(void)
{

    /*MAC driver position free*/
    if(Diag_u8IOCtrFlag[Diag_nu16MacPosDrCtrFree] == True)
    {
        if(Diag_u16IOCtrFreeTimer[Diag_nu16MacPosDrCtrFree]!=0u)
        {
            Diag_u16IOCtrFreeTimer[Diag_nu16MacPosDrCtrFree]--;
        }
        else
        {
            Diag_MacForceIOControl_ForceCtrl(Diag_nu32MacPosDrNormal); 
            Diag_u8IOCtrFlag[Diag_nu16MacPosDrCtrFree] = False;
        }
    }

    /*MAC Passenger position free*/
    if(Diag_u8IOCtrFlag[Diag_nu16MacPosPsCtrFree] == True)
    {
        if(Diag_u16IOCtrFreeTimer[Diag_nu16MacPosPsCtrFree]!=0u)
        {
            Diag_u16IOCtrFreeTimer[Diag_nu16MacPosPsCtrFree]--;
        }
        else
        {
            Diag_MacForceIOControl_ForceCtrl(Diag_nu32MacPosPsNormal);
            Diag_u8IOCtrFlag[Diag_nu16MacPosPsCtrFree] = False;
        }
    }
     /*Rfa position free*/
    if(Diag_u8IOCtrFlag[Diag_nu16RfaPosCtrFree] == True)
    {
        if(Diag_u16IOCtrFreeTimer[Diag_nu16RfaPosCtrFree]!=0u)
        {
            Diag_u16IOCtrFreeTimer[Diag_nu16RfaPosCtrFree]--;
        }
        else
        {
            Diag_RfaForceIOControl_ForceCtrl(Diag_nu32RfaPercentNormal);  
            Diag_u8IOCtrFlag[Diag_nu16RfaPosCtrFree] = False;
        }
    }

#if 0 /*no free request for the Aird and blower*/
    /*Aird mode status free*/
    if(Diag_u8IOCtrFlag[Diag_nu16AirdModeStsCtrFree] == True)
    {
        if(Diag_u16IOCtrFreeTimer[Diag_nu16AirdModeStsCtrFree]!=0u)
        {
            Diag_u16IOCtrFreeTimer[Diag_nu16AirdModeStsCtrFree]--;
        }
        else
        {
            Diag_AirdForceIOControl_ForceCtrl(Diag_nu32BctlSpdNormal); 
            Diag_u8IOCtrFlag[Diag_nu16AirdModeStsCtrFree] =False;
        }
    }


    /*blower speed free*/
    if(Diag_u8IOCtrFlag[Diag_nu16BctlSpdCtrFree] == True)
    {
        if(Diag_u16IOCtrFreeTimer[Diag_nu16BctlSpdCtrFree]!=0u)
        {
            Diag_u16IOCtrFreeTimer[Diag_nu16BctlSpdCtrFree]--;
        }
        else
        {
            Diag_BctlForceIOControl_ForceCtrl(Diag_nu32BctlSpdNormal);  
            Diag_u8IOCtrFlag[Diag_nu16BctlSpdCtrFree] = False;
        }
    }
    
#endif

     /*Accc Control free*/
    if(Diag_u8IOCtrFlag[Diag_nu16AcccActualReqCtrFree] == True)
    {
        if(Diag_u16IOCtrFreeTimer[Diag_nu16AcccActualReqCtrFree]!=0u)
        {
            Diag_u16IOCtrFreeTimer[Diag_nu16AcccActualReqCtrFree]--;
        }
        else
        {
            Diag_AcccForceIOControl_ForceCtrl(Diag_nu32AcccActualReqNormal);  
            Diag_u8IOCtrFlag[Diag_nu16AcccActualReqCtrFree] = False;
        }
    }

     /*ION Control free*/
    if(Diag_u8IOCtrFlag[Diag_nu16IonReqCtrFree] == True)
    {
        if(Diag_u16IOCtrFreeTimer[Diag_nu16IonReqCtrFree]!=0u)
        {
            Diag_u16IOCtrFreeTimer[Diag_nu16IonReqCtrFree]--;
        }
        else
        {
            Diag_IonForceIOControl_ForceCtrl(Diag_nu32IONReqNormal); 
            Diag_u8IOCtrFlag[Diag_nu16IonReqCtrFree] = False;
        }
    }

     /*Led Control free*/
    if(Diag_u8IOCtrFlag[Diag_nu16LedPWMCtrFree] == True) 
    {
        if(Diag_u16IOCtrFreeTimer[Diag_nu16LedPWMCtrFree]!=0u)
        {
            Diag_u16IOCtrFreeTimer[Diag_nu16LedPWMCtrFree]--;
        }
        else
        {
            Diag_DimForceIOControl_ForceCtrl(Diag_nu32LedPWMNormal);  
            Diag_u8IOCtrFlag[Diag_nu16LedPWMCtrFree] = False;
        } 
    }

     /*Lcd Control free*/
    if(Diag_u8IOCtrFlag[Diag_nu16LcdPWMCtrFree] == True) 
    {
        if(Diag_u16IOCtrFreeTimer[Diag_nu16LcdPWMCtrFree]!=0u)
        {
            Diag_u16IOCtrFreeTimer[Diag_nu16LcdPWMCtrFree]--;
        }
        else
        {
            Diag_LcdForceIOControl_ForceCtrl(Diag_nu32LcdPWMNormal);  
            Diag_u8IOCtrFlag[Diag_nu16LcdPWMCtrFree] = False;
        } 
    }
    

    if(Diag_u8IOCtrFlag[Diag_nu16RdcReqCtrFree] == True) 
    {
        if(Diag_u16IOCtrFreeTimer[Diag_nu16RdcReqCtrFree]!=0u)
        {
            Diag_u16IOCtrFreeTimer[Diag_nu16RdcReqCtrFree]--;
        }
        else
        {
            Diag_ReDefForceIOControl_ForceCtrl(Diag_nu32RdcReqNormal);  
            Diag_u8IOCtrFlag[Diag_nu16RdcReqCtrFree] = False; 
        }
    }

    /*PM25 control*/
    if(Diag_u8IOCtrFlag[Diag_nu16PM25ReqCtrFree] == True) 
    {
        if(Diag_u16IOCtrFreeTimer[Diag_nu16PM25ReqCtrFree]!=0u)
        {
            Diag_u16IOCtrFreeTimer[Diag_nu16PM25ReqCtrFree]--;
        }
        else
        {
            Diag_IonForceIOControl_ForceCtrl(Diag_nu32PM25ReqNormal);  
            Diag_u8IOCtrFlag[Diag_nu16PM25ReqCtrFree] = False; 
        }
    }

}


static void Diag_vSelfTestCheck(void)
{
    uint8 u8Res = 0x05;/*not successful*/
    uint32 u32BlowerCtr,u32DCMCommand;
    uint16 u16DCMPos;
      
    if(Diag_boSelfTestReq == True)
    {
        DIAG_au8Array[DIAG_nu8SelfTestReq] = True;
    }
    else
    {
        DIAG_au8Array[DIAG_nu8SelfTestReq] = False;
    }
      
    if(Diag_boSelfTestReq == True)
    {     
        if(Diag_SelfTestRoutineTimer == 0)
        {
            /*Stop the routine*/
            Diag_boSelfTestReq = False;
            u8Res = 0x04;/*Routine Complete successfully*/
            Diag_BctlForceIOControl_ForceCtrl(Diag_nu32BctlSpdNormal);
            Diag_MacForceIOControl_ForceCtrl(Diag_nu32MacPosDrNormal);
            Diag_MacForceIOControl_ForceCtrl(Diag_nu32MacPosPsNormal);
            Diag_AirdForceIOControl_ForceCtrl(Diag_nu32AirdPosNormal);
            Diag_RfaForceIOControl_ForceCtrl(Diag_nu32RfaPercentNormal);
            
            Desc_vPendingResDataProcess(0x31,&u8Res,0x01); 
            DescProcessingDone();
            
        }
        else if((Diag_SelfTestRoutineTimer==Diag_SelfTestTimeCfg1))
        {
            /*set blower 2 Bar,move to the max cool*/
            u32BlowerCtr = Diag_nu32BctlSpdCtr|0x02;
            Diag_BctlForceIOControl_ForceCtrl(u32BlowerCtr);

            /*Control the Mix driver motor*/
            u16DCMPos = Diag_u16MixMotorFbAdValueDr;           
            if(u16DCMPos < ((Diag_nu16MacDrMaxPos+Diag_nu16MacDrMinPos)/2))
            {
                u16DCMPos = Diag_nu16MacDrMaxPos;
            }
            else
            {
                u16DCMPos = Diag_nu16MacDrMinPos;
            }
            u32DCMCommand = Diag_nu32MacPosDrCtr|u16DCMPos;
            Diag_MacForceIOControl_ForceCtrl(u32DCMCommand);

            /*Control the Mix driver motor*/            
            u16DCMPos = Diag_u16MixMotorFbAdValuePs;           
            if(u16DCMPos < ((Diag_nu16MacPsMaxPos+Diag_nu16MacPsMinPos)/2))
            {
                u16DCMPos = Diag_nu16MacPsMaxPos;
            }
            else
            {
                u16DCMPos = Diag_nu16MacPsMinPos;
            }
            u32DCMCommand = Diag_nu32MacPosPsCtr|u16DCMPos;
            Diag_MacForceIOControl_ForceCtrl(u32DCMCommand);


           /*Control the aird motor*/    
            u16DCMPos = Diag_u16AirdMotorFbAdValue;           
            if(u16DCMPos < ((Diag_nu16AirdMaxPos+Diag_nu16AirdMinPos)/2))
            {
                u16DCMPos = Diag_nu16AirdMaxPos;
            }
            else
            {
                u16DCMPos = Diag_nu16AirdMinPos;
            }            
            u32DCMCommand = Diag_nu32AirdPosCtr|u16DCMPos;            
            Diag_AirdForceIOControl_ForceCtrl(u32DCMCommand);

            /*Control the RFA motor*/
            u16DCMPos = Diag_u16RfaMotorFbAdValue;   
            if(u16DCMPos < ((Diag_nu16RfaMaxPos+Diag_nu16RfaMinPos)/2))
            {
                u16DCMPos = 100; /*100%*//*REC*/
            }
            else
            {
                u16DCMPos = 0; /* 0% */
            }              
            Diag_RfaForceIOControl_ForceCtrl(Diag_nu32RfaPercentCtr|u16DCMPos);
            
        }
#if 0        
        else if(Diag_SelfTestRoutineTimer>=Diag_SelfTestTimeCfg2)
        {           
            /*set blower 2 Bar,move to the max hot*/
            u32BlowerCtr = Diag_nu32BctlSpdCtr|0x02;
            Diag_BctlForceIOControl_ForceCtrl(u32BlowerCtr);
            u32DCMCommand = Diag_nu32MacPosDrCtr|Diag_nu16MacDrMinPos;
            Diag_MacForceIOControl_ForceCtrl(u32DCMCommand);
            u32DCMCommand = Diag_nu32MacPosPsCtr|Diag_nu16MacPsMinPos;
            Diag_MacForceIOControl_ForceCtrl(u32DCMCommand);
            u32DCMCommand = Diag_nu32AirdPosCtr|Diag_nu16AirdMinPos;
            Diag_AirdForceIOControl_ForceCtrl(u32DCMCommand);
            Diag_RfaForceIOControl_ForceCtrl(Diag_nu32RfaPercentCtr|0);

        }   
        
#endif 
        if(Diag_SelfTestRoutineTimer>0)
        {
            Diag_SelfTestRoutineTimer--;
        }
    }
    else
    {
        
    }

}


/*  ********************************************************************************
 * Function name:Diag_vActiveCheck
 * Returns:  nothing
 * Description:
 *Most car manufactures have the requirement to keep the ECU alive while the diagnostic layer is active;
 *including a pending request or a non-default session is currently active.
 *This requirement is handled by CANdesc for some car manufactures
 *(see OEM specific TechnicalReference_CANdesc document for details)
 *The following code example shows all necessary steps to keep the ECU alive
 *while diagnostic jobs are running (e.g. non-default session):
 ********************************************************************************/
static void Diag_vActiveCheck(void)
{
    DescContextActivity lActivity;
    DescStateGroup lState;

    lActivity = DescGetActivityState();
    lState = DescGetStateSession();
    
    /* check for a pending request or a non-default session */
    if ( ((lState & kDescStateSessionDefault) == 0) ||(lActivity != kDescContextIdle) )
    {
        /* Force to stay alive */
        DIAG_au8Array[DIAG_nu8KeepAlive]=True;
    }
    else
    {
        /* Ready for sleeping */
        DIAG_au8Array[DIAG_nu8KeepAlive]=False;

    }
}


static void Diag_vPutValue2Rte(void)
{
#if 0
    Rte_IWrite_Diag_vMain_DiagRCPMount_u8Flag(DIAG_u8RCPMount);
    Rte_IWrite_Diag_vMain_DiagAQSMount_u8Flag(DIAG_u8AQSMount);
    Rte_IWrite_Diag_vMain_DiagPM25Mount_u8Flag(DIAG_u8PM25Mount);
    Rte_IWrite_Diag_vMain_DiagIonMount_u8Flag(DIAG_u8IONMount);/*Add by LT 20160806*/
    Rte_IWrite_Diag_vMain_DiagCommunicatonEnable_u8Flag(DIAG_u8AppRxDisable);
    Rte_IWrite_Diag_vMain_DiagEngineType_u8State(DIAG_u8EngType);
    Rte_IWrite_Diag_vMain_DiagSwVersion_u8Version(DIAG_u8SwVersion);
#endif
}




static void Diag_vFuntionCfg(void)
{
    DIAG_au8Array[DIAG_nu8EngType] = Diag_au8Group1FunctionCfg[0];
    
    if((Diag_au8Group1FunctionCfg[1]&0x03)==0x02)/*bit 0,1*/
    {
        DIAG_au8Array[DIAG_nu8AQSMount] = True;
    }
    else
    {
        DIAG_au8Array[DIAG_nu8AQSMount] = False;
    }

    if((Diag_au8Group1FunctionCfg[1]&0x0C)==0x08)/*bit 2,3*/
    {
        DIAG_au8Array[DIAG_nu8RCPMount] = True;
    }
    else
    {
        DIAG_au8Array[DIAG_nu8RCPMount] = False;
    }   

    if((Diag_au8Group1FunctionCfg[1]&0x30)==0x20)/*bit 4,5*/
    {
        DIAG_au8Array[DIAG_nu8PM25Mount] = True;
    }
    else
    {
        DIAG_au8Array[DIAG_nu8PM25Mount] = False;
    } 

    if((Diag_au8Group1FunctionCfg[1]&0xC0)==0x80)/*bit 6,7*/
    {
        DIAG_au8Array[DIAG_nu8IONMount] = True;
    }
    else
    {
        DIAG_au8Array[DIAG_nu8IONMount] = False;
    } 
    
}


static void Diag_vPendingResCkeck(void)
{
    uint8 u8Res,u8Result;/*Release Warning,161024*/
    u8Res=0xFFU;/*NO USE*/
    if(Diag_u8ClearDTCPeingReq == True)
    {
        Diag_u8ClearDTCPeingReq = False;
         u8Result = Diag_u8ClearAllDtc();//Rte_Call_Diag_DtcClearAllDtc_DtcClear();
         
         if(u8Result != 0)  /*No successful*/           
         {
            DescSetNegResponse(kDescNrcGeneralReject);
           
         }        
         else
         {
            Desc_vPendingResDataProcess(0x14,&u8Res,0x00); 
         }
         DescProcessingDone();       
    }
}



void DIAG_vReset(void)
{

  uint16 u16DataLen;
  uint8 u8Result;
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */  

  u16DataLen = sizeof(Diag_stLayout)-2; /*not include the check sum*/
  u8Result = Rte_Call_IoHwEep_IoHwEedProto_ReadEep_DiagData_EedRead(&Diag_u8Group1VariableConst,u16DataLen);//Rte_Call_Diag_ReadEep_DiagData_EedRead(&Diag_u8Group1VariableConst,u16DataLen);
  
  if(u8Result != 0) /*not successful*/
  {
      memcpy(&Diag_stLayout,&Diag_stDefaultLayout,sizeof(Diag_stLayout));   
  }

  DescSetAttemptCounterValue(Diag_nu8SecureNrOfAttempts);

  Diag_u8ResetDelay = 1;   
  Diag_SelfTestRoutineTimer =0;  
  Diag_boSelfTestReq = False;
  DIAG_au8Array[DIAG_nu8AppRxDisable] = False;
  DIAG_au8Array[DIAG_nu8ResetFlag] = False;
  DIAG_au8Array[DIAG_nu8SelfTestReq] = False;/*Add by LT,20161122*/
  Diag_u8ClearDTCPeingReq = False;
  Diag_biHardReset = False;
  Diag_biSoftReset = False;
  Diag_vFuntionCfg();

}

void DIAG_vMain(void)
{
    Diag_vHardReset();
    Diag_vSoftReset();
    Diag_vRandSeed();
    Diag_vSaveSecureTimer();
    Diag_vSessionCheck();
    //Diag_vIOCtrFreeCheck();/*move to the session check, will error with the internal test,20160706*/
    Diag_vSelfTestCheck();
    Diag_vActiveCheck();
    Diag_vPendingResCkeck();
    Diag_vPutValue2Rte();
}

void DIAG_vInit(void)
{
    uint8 u8i;
    Diag_biHardReset = False;
    Diag_biSoftReset = False;
    //Diag_u16PendingResTimer = 0;/*Release Warning,161024*/
    //Diag_boPendingResReq = False;/*Release Warning,161024*/
    Diag_u8LastSessionControl = 0xFF;
    DescInit(0);	
    Diag_u8ResetDelay = 1; 
    
    for(u8i=0;u8i<Diag_nu16CtrFreeMax;u8i++)
    {        
        Diag_u16IOCtrFreeTimer[u8i]=0u;
    }
    
    //DescSetStateSecurityAccess(kDescStateSecurityAccessUnlockedL1);
    Diag_SelfTestRoutineTimer = 0;
    Diag_boSelfTestReq = False;
    DIAG_au8Array[DIAG_nu8ResetFlag] = False; 
    DIAG_au8Array[DIAG_nu8SelfTestReq] = False;/*Add by LT,20161122*/
    Diag_u8ClearDTCPeingReq = False;
    Diag_vFuntionCfg();
    CANNMAPP_vClearStayWakeByDiag();

}

void DIAG_vDeinit(void)
{
    Diag_biHardReset = False;
    Diag_biSoftReset = False;
    DIAG_au8Array[DIAG_nu8SelfTestReq] = False;/*Add by LT,20161122*/

}

void DIAG_vActive(void)
{
    /*Add by LT,20161130*/
    Diag_vHardReset();
    Diag_vSoftReset();
    Diag_vRandSeed();
    Diag_vSaveSecureTimer();
    Diag_vSessionCheck();
    Diag_vSelfTestCheck();
    Diag_vActiveCheck();
    Diag_vPendingResCkeck();
    Diag_vPutValue2Rte();


}

/* -----------------------------------------------------------------------------
    &&&~ Implementation
 ----------------------------------------------------------------------------- */

#if defined (DESC_ENABLE_DEBUG_USER ) || defined (DESC_ENABLE_DEBUG_INTERNAL)
# if defined (CCL_ENABLE_ERROR_HOOK) || defined (CCLCOM_ENABLE_ERROR_HOOK)
/* CCL takes care about this function */
# else
/* ********************************************************************************
 * Function name:ApplDescFatalError
 * Description: This function will be called each time while the debug mode is active a
 * CANdesc fault has been detected. If you reach this function it makes no sence to continue the tests since CANdesc
 * will not operate properly until next start of the ECU.
 * Returns:  nothing
 * Parameter(s):
 *   - errorCode:
 *       - The assert code text equivalent can be found in desc.h (kDescAssert....).
 *       - Access type: read
 *   - lineNumber:
 *       - Since the same fault could be cales on many places the line number shows where exactly it occured.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - Set a break point at this place to know during the ECU development if you ran onto it.
 ******************************************************************************** */
void DESC_API_CALLBACK_TYPE ApplDescFatalError(vuint8 errorCode, vuint16 lineNumber)
{
  /*<<TBD>> Remove this comment once you have completely implemented this function!!!*/
  /* Avoid warnings */
  DESC_IGNORE_UNREF_PARAM(errorCode);
  DESC_IGNORE_UNREF_PARAM(lineNumber);

  /* When fatal error occurs, cause an ECU hang up at this point.
   * Please set break point at this line to investigate both parameter values. */
  for(;;);
}
# endif
#endif

/*  ********************************************************************************
 * Function name:ApplDescRcrRpConfirmation
 * Description:Will be called only if "DescForceRcrRpResponse" has been previously called.
 * Returns:  nothing
 * Parameter(s):
 *   - status:
 *       - Current RCR-RP transmission status (kDescOk/kDescFailed).
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may be called to close the service processing.
 *   - The function "DescSetNegResponse" may be called to set a negative response.
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRcrRpConfirmation(vuint8 status)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
    /* Avoid warnings */
  DESC_CONTEXT_PARAM_DUMMY_USE;

  /* Check the transmission status */
  if(status == kDescOk)
  {
    /* "Response Pending" was just successfully sent, you can perform any further action knowing that
     * from now on the tester has restarted its response timeout timer and set the next time to P2* (P2Ex) 
     */
  }
  else
  {
    /* There was some transmission error and the tester didn't received the RCR-RP response. You can decide to go on
     * or to reset the application activity you have started and wait for a new request from the tester. 
     */
  }
;
}


/*  ********************************************************************************
 * Function name:ApplDescOnTransitionSession
 * Description:Notification function for state change of the given state group, defined by
 * CANdelaStudio.
 * Returns:  nothing
 * Parameter(s):
 *   - newState:
 *       - The state which will be set.
 *       - Access type: read
 *   - formerState:
 *       - The current state of this state group.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescOnTransitionSession(DescStateGroup newState, DescStateGroup formerState)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
   /* This is only a notification function. Using the "formerState" and the "newState" 
   * parameter you can distinguish the different transitions for this state group.
   */
  /* Avoids warnings */
  DESC_IGNORE_UNREF_PARAM(newState);
  DESC_IGNORE_UNREF_PARAM(formerState);
;
}


/*  ********************************************************************************
 * Function name:ApplDescOnTransitionSecurityAccess
 * Description:Notification function for state change of the given state group, defined by
 * CANdelaStudio.
 * Returns:  nothing
 * Parameter(s):
 *   - newState:
 *       - The state which will be set.
 *       - Access type: read
 *   - formerState:
 *       - The current state of this state group.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescOnTransitionSecurityAccess(DescStateGroup newState, DescStateGroup formerState)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
   /* This is only a notification function. Using the "formerState" and the "newState" 
   * parameter you can distinguish the different transitions for this state group.
   */
  /* Avoids warnings */
  DESC_IGNORE_UNREF_PARAM(newState);
  DESC_IGNORE_UNREF_PARAM(formerState);
;
}


/*  ********************************************************************************
 * Function name:ApplDescResethardReset (Service request header:$11 $1 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescResethardReset(DescMsgContext* pMsgContext)
{

  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Contains no response data */
  /* User service processing finished. */
  uint16 u16Engine,u16EngSpdValid;

  u16Engine = Diag_u16EngSpd;/*ALWAYS ALLOW,BY ZSC,160524*/
  u16EngSpdValid = Diag_u16EngSpdValid;/*0 is valid*/  /*ALWAYS ALLOW,BY ZSC,160524*/
  
  if((u16EngSpdValid == 0U)&&(u16Engine>0U)&&(u16Engine!=0xFFFFU)&&(u16Engine!=0xFFFEU))/*Engine is running*/
  {
	  /* Request contains invalid data - send negative response! */
	  DescSetNegResponse(kDescNrcConditionsNotCorrect);
  }
  else
  {
  }

  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescResetsoftReset (Service request header:$11 $3 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescResetsoftReset(DescMsgContext* pMsgContext)
{
  uint16 u16Engine,u16EngSpdValid;

  u16Engine = Diag_u16EngSpd;
  u16EngSpdValid = Diag_u16EngSpdValid;/*0 is valid*/
  
  if((u16EngSpdValid == 0U)&&(u16Engine>0U)&&(u16Engine!=0xFFFFU)&&(u16Engine!=0xFFFEU))/*Engine is running*/
  {
	  /* Request contains invalid data - send negative response! */
	  DescSetNegResponse(kDescNrcConditionsNotCorrect);
  }
  else
  {
  }
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescClearFaultMemory (Service request header:$14 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescClearFaultMemory(DescMsgContext* pMsgContext)
{
    //uint8 u8Result;/*Release Warning,161024*/
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Dummy example how to access the request data. */
  /* Assumming the FIRST DATA byte contains important data which has to be less than a constant value. */
  if((pMsgContext->reqData[0] == 0xFF) && (pMsgContext->reqData[1] == 0xFF) && (pMsgContext->reqData[2] == 0xFF))
  {
    /* Received data is in range process further. */
    /* Contains no response data */
         DescForceRcrRpResponse(); /*avoid timeout*/
         Diag_u8ClearDTCPeingReq = True;

  }
  else
  {
    /* Request contains invalid data - send negative response! */
    DescSetNegResponse(kDescNrcRequestOutOfRange);
    DescProcessingDone();

  }
  /* User service processing finished. */
}


/*  ********************************************************************************
 * Function name:ApplDescReadNumberFaultMemory (Service request header:$19 $1 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadNumberFaultMemory(DescMsgContext* pMsgContext)
{
  uint8 u8Mask,u8Res[4],u8Length,u8Result;
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Dummy example how to access the request data. */
  /* Assumming the FIRST DATA byte contains important data which has to be less than a constant value. */
  u8Mask = pMsgContext->reqData[0];
  u8Result = Diag_u8ReadMaskFaultDtcNum(&u8Mask,&u8Res[0],&u8Length);//Rte_Call_Diag_DtcReadMaskFaultNum_DtcRead(&u8Mask,&u8Res[0],&u8Length);

  if((u8Result == RTE_E_OK)&&(u8Length==0x04U))
  {   
	pMsgContext->resData[0]=u8Res[0];/* availablemask*/
	pMsgContext->resData[1]=u8Res[1];   /*0:ISO15031-6DTCFormat*/
    pMsgContext->resData[2]=u8Res[2];
	pMsgContext->resData[3]=u8Res[3];
	pMsgContext->resDataLen = 4;
  }
  else
  {
    /* Request contains invalid data - send negative response! */
    DescSetNegResponse(kDescNrcRequestOutOfRange);
  }
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescRead_DTC_by_status_maskFaultMemory (Service request header:$19 $2 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_DTC_by_status_maskFaultMemory(DescMsgContext* pMsgContext)
{
  uint8 u8Mask,u8Length,u8Result;
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Dummy example how to access the request data. */
  /* Assumming the FIRST DATA byte contains important data which has to be less than a constant value. */
  u8Mask = pMsgContext->reqData[0];
  u8Result = Diag_u8ReadMaskFaultDtcList(&u8Mask,&pMsgContext->resData[0],&u8Length);//Rte_Call_Diag_DtcReadMaskFaultList_DtcRead(&u8Mask,&pMsgContext->resData[0],&u8Length);
  
  if(u8Result == RTE_E_OK)
  {
    /* Received data is in range process further. */
    /* Dummy example of how to write the response data. */
    /* Always set the correct length of the response data. */

    /*plese check if the length will more than 255,length=4*DTCNum+1*/
    pMsgContext->resDataLen = u8Length;
  }
  else
  {
    /* Request contains invalid data - send negative response! */
    DescSetNegResponse(kDescNrcRequestOutOfRange);
  }
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescReadEnvironmentDataFaultMemory (Service request header:$19 $4 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadEnvironmentDataFaultMemory(DescMsgContext* pMsgContext)
{
  uint8 u8Length,u8Result;
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Dummy example how to access the request data. */
  /* Assumming the FIRST DATA byte contains important data which has to be less than a constant value. */

  u8Result = Diag_u8ReadSnapShotData(&pMsgContext->reqData[0],&pMsgContext->resData[0],&u8Length);//Rte_Call_Diag_DtcReadSnapShotData_DtcRead(&pMsgContext->reqData[0],&pMsgContext->resData[0],&u8Length);
  
  if(u8Result == RTE_E_OK)
  {
    /* Received data is in range process further. */
    /* Dummy example of how to write the response data. */
    /* Always set the correct length of the response data. */
    pMsgContext->resDataLen = u8Length;
  }
  else
  {
    /* Request contains invalid data - send negative response! */
    DescSetNegResponse(kDescNrcRequestOutOfRange);
  }
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescRead_supported_DTCFaultMemory (Service request header:$19 $A )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_supported_DTCFaultMemory(DescMsgContext* pMsgContext)
{
  uint8 u8Result;
  uint16 u16Lenth;
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Dummy example how to access the request data. */
  /* Assumming the FIRST DATA byte contains important data which has to be less than a constant value. */
  u8Result = Diag_u8ReadSupportDtcList(&pMsgContext->reqData[0],&pMsgContext->resData[0],&u16Lenth);//Rte_Call_Diag_DtcReadSupportDtcList_DtcRead(&pMsgContext->reqData[0],&pMsgContext->resData[0],&u8Length);
  if(u8Result ==RTE_E_OK )
  {
        /* Always set the correct length of the response data. */
        pMsgContext->resDataLen = u16Lenth;
  }
  else
  {
        /* Request contains invalid data - send negative response! */
        DescSetNegResponse(kDescNrcRequestOutOfRange);
  }

  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescWriteBackup_configuration_information (Service request header:$2E $DF $EF )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescWriteBackup_configuration_information(DescMsgContext* pMsgContext)
{
    uint16 u16DataLen;
    uint16 u16i,u16Result;
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Dummy example how to access the request data. */
  /* Assumming the FIRST DATA byte contains important data which has to be less than a constant value. */
  u16DataLen = sizeof(Diag_stLayout)-2U; /*not include the check sum*/

  for(u16i = 0U; u16i < Diag_nBackupCfgInfor_len; u16i++)
  {
        Diag_stLayout.stGroup1.stDiagData.au8BackupCfgInfor[u16i] = pMsgContext->reqData[u16i];
  }  
  u16Result = Rte_Call_IoHwEep_IoHwEedProto_WriteEep_DiagData_EedWrite((uint8*)&Diag_stLayout,u16DataLen);//Rte_Call_Diag_WriteEep_DiagData_EedWrite(&Diag_stLayout,u16DataLen);
     
  if(u16Result == 0U) /*successful*/
  {
    /* Received data is in range process further. */
    /* Contains no response data */
  }
  else
  {
    /* Request contains invalid data - send negative response! */
    DescSetNegResponse(kDescNrcGeneralReject);
  }
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescWriteECUFunctionConfiguration (Service request header:$2E $F1 $1 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescWriteECUFunctionConfiguration(DescMsgContext* pMsgContext)
{
    uint16 u16DataLen;
    uint16 u16i,u16Result;
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Dummy example how to access the request data. */
  /* Assumming the FIRST DATA byte contains important data which has to be less than a constant value. */
  u16DataLen = sizeof(Diag_stLayout)-2U; /*not include the check sum*/

  for(u16i = 0U; u16i < Diag_nFunctionCfg_Len; u16i++)
  {
        Diag_stLayout.stGroup1.stDiagData.au8FunctionCfg[u16i] = pMsgContext->reqData[u16i];
  }  
  u16Result = Rte_Call_IoHwEep_IoHwEedProto_WriteEep_DiagData_EedWrite((uint8*)&Diag_stLayout,u16DataLen);//Rte_Call_Diag_WriteEep_DiagData_EedWrite(&Diag_stLayout,u16DataLen);
     
  if(u16Result == 0U) /*successful*/
  {
    /* Received data is in range process further. */
    /* Contains no response data */
  }
  else
  {
    /* Request contains invalid data - send negative response! */
    DescSetNegResponse(kDescNrcGeneralReject);
  }
  /* User service processing finished. */
  DescProcessingDone();
}

/*  ********************************************************************************
 * Function name:ApplDescWriteVehicleNetworkConfigurationDataIdentifier (Service request header:$2E $F1 $10 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescWriteVehicleNetworkConfigurationDataIdentifier(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Dummy example how to access the request data. */
  /* Assumming the FIRST DATA byte contains important data which has to be less than a constant value. */
  uint16 u16DataLen;
  uint16 u16i,u16Result;
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Dummy example how to access the request data. */
  /* Assumming the FIRST DATA byte contains important data which has to be less than a constant value. */
  u16DataLen = sizeof(Diag_stLayout)-2U; /*not include the check sum*/

  for(u16i = 0U; u16i < Diag_nVehicleNetworkConfiguration_Len; u16i++)
  {
        Diag_stLayout.stGroup1.stDiagData.au8VehicleNetworkConfiguration[u16i] = pMsgContext->reqData[u16i];
  }  
  u16Result = Rte_Call_IoHwEep_IoHwEedProto_WriteEep_DiagData_EedWrite((uint8*)&Diag_stLayout,u16DataLen);//Rte_Call_Diag_WriteEep_DiagData_EedWrite(&Diag_stLayout,u16DataLen);
     
  if(u16Result == 0U) /*successful*/
  {
    /* Received data is in range process further. */
    /* Contains no response data */
  }
  else
  {
    /* Request contains invalid data - send negative response! */
    DescSetNegResponse(kDescNrcGeneralReject);
  }
  /* User service processing finished. */
  DescProcessingDone();
}

/*  ********************************************************************************
 * Function name:ApplDescWriteVehicle_Name (Service request header:$2E $F1 $12 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescWriteVehicle_Name(DescMsgContext* pMsgContext)
{
    uint16 u16DataLen;
    uint16 u16i,u16Result;
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Dummy example how to access the request data. */
  /* Assumming the FIRST DATA byte contains important data which has to be less than a constant value. */
  u16DataLen = sizeof(Diag_stLayout)-2U; /*not include the check sum*/

  for(u16i = 0U; u16i < Diag_nVehicleName_Len; u16i++)
  {
        Diag_stLayout.stGroup1.stDiagData.au8VehicleName[u16i] = pMsgContext->reqData[u16i];
  }  
  u16Result = Rte_Call_IoHwEep_IoHwEedProto_WriteEep_DiagData_EedWrite((uint8*)&Diag_stLayout,u16DataLen);//Rte_Call_Diag_WriteEep_DiagData_EedWrite(&Diag_stLayout,u16DataLen);
     
  if(u16Result == 0U) /*successful*/
  {
    /* Received data is in range process further. */
    /* Contains no response data */
  }
  else
  {
    /* Request contains invalid data - send negative response! */
    DescSetNegResponse(kDescNrcGeneralReject);
  }
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescWriteVehicleIdentificationNumber (Service request header:$2E $F1 $90 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescWriteVehicleIdentificationNumber(DescMsgContext* pMsgContext)
{
    uint16 u16DataLen;
    uint16 u16i,u16Result;
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Dummy example how to access the request data. */
  /* Assumming the FIRST DATA byte contains important data which has to be less than a constant value. */
  u16DataLen = sizeof(Diag_stLayout)-2U; /*not include the check sum*/

  for(u16i = 0U; u16i < Diag_nvehicleIdentificationNumber_Len; u16i++)
  {
        Diag_stLayout.stGroup1.stDiagData.au8vehicleIdentificationNumber[u16i] = pMsgContext->reqData[u16i];
  }  
  u16Result = Rte_Call_IoHwEep_IoHwEedProto_WriteEep_DiagData_EedWrite((uint8*)&Diag_stLayout,u16DataLen);//Rte_Call_Diag_WriteEep_DiagData_EedWrite(&Diag_stLayout,u16DataLen);
     
  if(u16Result == 0U) /*successful*/
  {
    /* Received data is in range process further. */
    /* Contains no response data */
  }
  else
  {
    /* Request contains invalid data - send negative response! */
    DescSetNegResponse(kDescNrcGeneralReject);
  }
  /* User service processing finished. */
  DescProcessingDone();
}

/*  ********************************************************************************
 * Function name:ApplDescWriteSystemNameOrEngineType (Service request header:$2E $F1 $97 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescWriteSystemNameOrEngineType(DescMsgContext* pMsgContext)
{
    uint16 u16DataLen;
    uint16 u16i,u16Result;
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Dummy example how to access the request data. */
  /* Assumming the FIRST DATA byte contains important data which has to be less than a constant value. */
  u16DataLen = sizeof(Diag_stLayout)-2U; /*not include the check sum*/

  for(u16i = 0U; u16i < Diag_nSystemNameOrEngineType_Len; u16i++)
  {
        Diag_stLayout.stGroup1.stDiagData.au8SystemNameOrEngineType[u16i] = pMsgContext->reqData[u16i];
  }  
  u16Result = Rte_Call_IoHwEep_IoHwEedProto_WriteEep_DiagData_EedWrite((uint8*)&Diag_stLayout,u16DataLen);//Rte_Call_Diag_WriteEep_DiagData_EedWrite(&Diag_stLayout,u16DataLen);
     
  if(u16Result == 0U) /*successful*/
  {
    /* Received data is in range process further. */
    /* Contains no response data */
  }
  else
  {
    /* Request contains invalid data - send negative response! */
    DescSetNegResponse(kDescNrcGeneralReject);
  }
  /* User service processing finished. */
  DescProcessingDone();
}

/*  ********************************************************************************
 * Function name:ApplDescWriteRepairShopCodeOrTesterSerialNumber (Service request header:$2E $F1 $98 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescWriteRepairShopCodeOrTesterSerialNumber(DescMsgContext* pMsgContext)
{
    #if 0
    uint16 u16DataLen;
    uint16 u16i,u16Result;
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Dummy example how to access the request data. */
  /* Assumming the FIRST DATA byte contains important data which has to be less than a constant value. */
  u16DataLen = sizeof(Diag_stLayout)-2U; /*not include the check sum*/

  for(u16i = 0U; u16i < Diag_nRepairShopCodeOrTesterSerialNumber_Len; u16i++)
  {
        Diag_stLayout.stGroup1.stDiagData.au8RepairShopCodeOrTesterSerialNumber[u16i] = pMsgContext->reqData[u16i];
  }  
  u16Result = EED_u8WriteGroupData(2,(uint8*)&Diag_stLayout,u16DataLen);//Rte_Call_Diag_WriteEep_DiagData_EedWrite(&Diag_stLayout,u16DataLen);
  #endif
  uint16 u16Result;

  u16Result = Diag_u8WriteEEDData(RepairShopCodeOrTesterSNAddr,&pMsgContext->reqData[0],RepairShopCodeOrTesterSNLen);  
  if(u16Result == 0U) /*successful*/
  {
    /* Received data is in range process further. */
    /* Contains no response data */
  }
  else
  {
    /* Request contains invalid data - send negative response! */
    DescSetNegResponse(kDescNrcGeneralReject);
  }
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescWriteProgrammingOrConfigurationDate (Service request header:$2E $F1 $99 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescWriteProgrammingOrConfigurationDate(DescMsgContext* pMsgContext)
{
  #if 0
    uint16 u16DataLen;
    uint16 u16i,u16Result;
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Dummy example how to access the request data. */
  /* Assumming the FIRST DATA byte contains important data which has to be less than a constant value. */
  u16DataLen = sizeof(Diag_stLayout)-2U; /*not include the check sum*/

  for(u16i = 0U; u16i < Diag_nProgrammingOrConfigurationDate_Len; u16i++)
  {
        Diag_stLayout.stGroup1.stDiagData.au8ProgrammingOrConfigurationDate[u16i] = pMsgContext->reqData[u16i];
  }  
  u16Result = EED_u8WriteGroupData(2,(uint8*)&Diag_stLayout,u16DataLen);//Rte_Call_Diag_WriteEep_DiagData_EedWrite(&Diag_stLayout,u16DataLen);
 #endif

  uint16 u16Result;
  u16Result = Diag_u8WriteEEDData(ProgrammingOrConfigurationDateAddr,&pMsgContext->reqData[0],ProgrammingOrConfigurationDateLen);
 
  if(u16Result == 0U) /*successful*/
  {
    /* Received data is in range process further. */
    /* Contains no response data */
  }
  else
  {
    /* Request contains invalid data - send negative response! */
    DescSetNegResponse(kDescNrcGeneralReject);
  }
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescWriteECUInstallationDateDataIdentifier (Service request header:$2E $F1 $9D )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescWriteECUInstallationDateDataIdentifier(DescMsgContext* pMsgContext)
{
    uint16 u16DataLen;
    uint16 u16i,u16Result;
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Dummy example how to access the request data. */
  /* Assumming the FIRST DATA byte contains important data which has to be less than a constant value. */
  u16DataLen = sizeof(Diag_stLayout)-2U; /*not include the check sum*/

  for(u16i = 0U; u16i < Diag_nECUInstallationDateDataIdentifier_Len; u16i++)
  {
        Diag_stLayout.stGroup1.stDiagData.au8ECUInstallationDateDataIdentifier[u16i] = pMsgContext->reqData[u16i];
  }  
  u16Result = Rte_Call_IoHwEep_IoHwEedProto_WriteEep_DiagData_EedWrite((uint8*)&Diag_stLayout,u16DataLen);//Rte_Call_Diag_WriteEep_DiagData_EedWrite(&Diag_stLayout,u16DataLen);
     
  if(u16Result == 0U) /*successful*/
  {
    /* Received data is in range process further. */
    /* Contains no response data */
  }
  else
  {
    /* Request contains invalid data - send negative response! */
    DescSetNegResponse(kDescNrcGeneralReject);
  }
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescControl_ResetDriverTempActuator (Service request header:$2F $63 $0 $0 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescControl_ResetDriverTempActuator(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */
  
  Diag_MacForceIOControl_ForceCtrl(Diag_nu32MacPosDrNormal);
  Diag_u8IOCtrFlag[Diag_nu16MacPosDrCtrFree] = False;
  pMsgContext->resData[0] = 0x00; /*returnControlToECU*/
  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 1;
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescControlDriverTempActuator (Service request header:$2F $63 $0 $3 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescControlDriverTempActuator(DescMsgContext* pMsgContext)
{
  uint16 u16CtrlValue;
  uint32 u32Command;
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */
  
  u16CtrlValue= pMsgContext->reqData[0];
  u16CtrlValue<<=2; /*10 bit AD*/
  u32Command = Diag_nu32MacPosDrCtr|((uint32)u16CtrlValue);
  Diag_MacForceIOControl_ForceCtrl(u32Command);
  
  pMsgContext->resData[0]=0x03U;
  pMsgContext->resData[1]=pMsgContext->reqData[0];
  pMsgContext->resDataLen=2U;
  
  Diag_u16IOCtrFreeTimer[Diag_nu16MacPosDrCtrFree]=Diag_nu16IOCtrFreeTime;
  Diag_u8IOCtrFlag[Diag_nu16MacPosDrCtrFree] = True;
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescControl_ResetLoopmode (Service request header:$2F $63 $8 $0 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescControl_ResetLoopmode(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */
  Diag_RfaForceIOControl_ForceCtrl(Diag_nu32RfaPercentNormal);
  Diag_u8IOCtrFlag[Diag_nu16RfaPosCtrFree] = False;

  pMsgContext->resData[0] = 0x00U; /*returnControlToECU*/
  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 1;
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescControlLoopmode (Service request header:$2F $63 $8 $3 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescControlLoopmode(DescMsgContext* pMsgContext)
{
  uint16 u16CtrlValue;
  uint32 u32Command;
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */
  if(pMsgContext->reqData[0]<=1U)
  {
      //u16CtrlValue=(uint16)pMsgContext->reqData[0];
      if(pMsgContext->reqData[0]==0)
      {
        u16CtrlValue = 100;/*REC*/
      }
      else
      {
        u16CtrlValue = 0;/*Fresh*/
      }
      u32Command = Diag_nu32RfaPercentCtr|((uint32)u16CtrlValue);
      Diag_RfaForceIOControl_ForceCtrl(u32Command);
      
      pMsgContext->resData[0]=0x03U;
      pMsgContext->resData[1]=pMsgContext->reqData[0];
      pMsgContext->resDataLen=2U;
      Diag_u16IOCtrFreeTimer[Diag_nu16RfaPosCtrFree]=Diag_nu16IOCtrFreeTime;
      Diag_u8IOCtrFlag[Diag_nu16RfaPosCtrFree] = True;
  }
  else
  {
      /* Request contains invalid data - send negative response! */
      DescSetNegResponse(kDescNrcRequestOutOfRange);    
  }
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescControl_ResetIONControl (Service request header:$2F $63 $9 $0 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescControl_ResetIONControl(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */
  Diag_IonForceIOControl_ForceCtrl(Diag_nu32IONReqNormal);
  Diag_u8IOCtrFlag[Diag_nu16IonReqCtrFree] = False;

  pMsgContext->resData[0] = 0x00;
  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 1;
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescControlIONControl (Service request header:$2F $63 $9 $3 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescControlIONControl(DescMsgContext* pMsgContext)
{
    uint32 u32Command;
    uint16 u16CtrlValue;
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Dummy example how to access the request data. */
  /* Assumming the FIRST DATA byte contains important data which has to be less than a constant value. */
  if(pMsgContext->reqData[0] <= 1u)
  {
    /* Received data is in range process further. */
    /* Dummy example of how to write the response data. */
    u16CtrlValue=(uint16)pMsgContext->reqData[0];
    u32Command = Diag_nu32IONReqCtr|((uint32)u16CtrlValue);
    Diag_IonForceIOControl_ForceCtrl(u32Command);
    pMsgContext->resData[0]=0x03;
    pMsgContext->resData[1]=pMsgContext->reqData[0];
    pMsgContext->resDataLen=2;
    Diag_u16IOCtrFreeTimer[Diag_nu16IonReqCtrFree] = Diag_nu16IOCtrFreeTime;
    Diag_u8IOCtrFlag[Diag_nu16IonReqCtrFree] = True;

  }
  else
  {
    /* Request contains invalid data - send negative response! */
    DescSetNegResponse(kDescNrcRequestOutOfRange);
  }
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescControl_ResetBlower_Level (Service request header:$2F $63 $B $0 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescControl_ResetBlower_Level(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */
  Diag_BctlForceIOControl_ForceCtrl(Diag_nu32BctlSpdNormal);
  Diag_u8IOCtrFlag[Diag_nu16BctlSpdCtrFree] = False;
 
  pMsgContext->resData[0] = 0x00; /*returnControlToECU*/
  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 1;
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescControlBlower_Level (Service request header:$2F $63 $B $3 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescControlBlower_Level(DescMsgContext* pMsgContext)
{
  uint16 u16CtrlValue;
  uint32 u32Command;
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */
  if(pMsgContext->reqData[0]<=8U)
  {
        u16CtrlValue=(uint16)pMsgContext->reqData[0];
        u32Command = Diag_nu32BctlSpdCtr|((uint32)u16CtrlValue);
        Diag_BctlForceIOControl_ForceCtrl(u32Command);
        pMsgContext->resData[0]=0x03;
        pMsgContext->resData[1]=pMsgContext->reqData[0];
        pMsgContext->resDataLen=2;      
      //Diag_u16IOCtrFreeTimer[Diag_nu16BctlSpdCtrFree]=Diag_nu16IOCtrFreeTime;
  }
  else
  {
      /* Request contains invalid data - send negative response! */
      DescSetNegResponse(kDescNrcRequestOutOfRange);  
  }
  


  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescControl_ResetModeActuator (Service request header:$2F $63 $C $0 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescControl_ResetModeActuator(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */
  
  Diag_AirdForceIOControl_ForceCtrl(Diag_nu32AirdModeStsNormal);
  Diag_u8IOCtrFlag[Diag_nu16AirdModeStsCtrFree] = False;
 
  pMsgContext->resData[0] = 0x00; /*returnControlToECU*/
  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 1;
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescControlModeActuator (Service request header:$2F $63 $C $3 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescControlModeActuator(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Dummy example how to access the request data. */
  /* Assumming the FIRST DATA byte contains important data which has to be less than a constant value. */
  uint16 u16CtrlValue;
  uint32 u32Command;
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */ 
  if((pMsgContext->reqData[0]>=1u)&&(pMsgContext->reqData[0]<=5u))
  {
        switch(pMsgContext->reqData[0])
        {
            case 1: /*face*/
            u16CtrlValue = 0;   
            break;
            case 2:/*foot*/
            u16CtrlValue = 2;                   
            break;
            case 3: /*bilevel*/
            u16CtrlValue = 1;   
            break;
            case 4:/*mixed*/
            u16CtrlValue = 3;                   
            break;
            case 5:/*defrost*/
            u16CtrlValue = 4;  
            break;
            default:
            break;
        }
        u32Command = Diag_nu32AirdModeStsCtr|((uint32)u16CtrlValue);
        Diag_AirdForceIOControl_ForceCtrl(u32Command);
        pMsgContext->resData[0]=0x03U;
        pMsgContext->resData[1]=pMsgContext->reqData[0];
        pMsgContext->resDataLen=2U;        
        //Diag_u16IOCtrFreeTimer[Diag_nu16AirdModeStsCtrFree]=Diag_nu16IOCtrFreeTime;
  }
  else
  {
        /* Request contains invalid data - send negative response! */
        DescSetNegResponse(kDescNrcRequestOutOfRange);
  }

  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescControl_ResetRearDefrostControl(Service request header:$2F $63 $E $0 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescControl_ResetRearDefrostControl(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */
#if 0
  Diag_DimForceIOControl_ForceCtrl(Diag_nu32RdcLedStatusNormal);
  Diag_u8IOCtrFlag[Diag_nu16RdcReqCtrFree] = False;
 
  pMsgContext->resData[0] = 0x00; /*returnControlToECU*/
  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 1;
#endif
 DescSetNegResponse(kDescNrcRequestOutOfRange);
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescControlRearDefrostControl_Force (Service request header:$2F $63 $E $3 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescControlRearDefrostControl(DescMsgContext* pMsgContext)
{
#if 0
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Dummy example how to access the request data. */
  /* Assumming the FIRST DATA byte contains important data which has to be less than a constant value. */
  uint32 u32Command =0;
  
  if(pMsgContext->reqData[0] <= 0x01)
  {
        u32Command = Diag_nu32RdcLedStatusForce|((uint32)pMsgContext->reqData[0]);
        Diag_DimForceIOControl_ForceCtrl(u32Command);
        Diag_u16IOCtrFreeTimer[Diag_nu16RdcReqCtrFree]=Diag_nu16IOCtrFreeTime;
        Diag_u8IOCtrFlag[Diag_nu16RdcReqCtrFree] = True; 

        pMsgContext->resData[0]=0x03U;
        pMsgContext->resData[1]=pMsgContext->reqData[0];
        pMsgContext->resDataLen=2U;   
  }
  else
  {
    /* Request contains invalid data - send negative response! */
    DescSetNegResponse(kDescNrcRequestOutOfRange);
  }
  #endif
  DescSetNegResponse(kDescNrcRequestOutOfRange);
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescControl_ResetCompressorControl (Service request header:$2F $63 $F $0 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescControl_ResetCompressorControl(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */
  Diag_AcccForceIOControl_ForceCtrl(Diag_nu32AcccActualReqNormal);
  Diag_u8IOCtrFlag[Diag_nu16AcccActualReqCtrFree] = False;
 
  pMsgContext->resData[0] = 0x00; /*returnControlToECU*/
  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 1;
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescControlCompressorControl (Service request header:$2F $63 $F $3 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescControlCompressorControl(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Dummy example how to access the request data. */
  /* Assumming the FIRST DATA byte contains important data which has to be less than a constant value. */
  uint16 u16CtrlValue;
  uint32 u32Command;
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */
  if(pMsgContext->reqData[0]<=1)
  {
      u16CtrlValue=(uint16)pMsgContext->reqData[0];
      u32Command = Diag_nu32AcccActualReqCtr|((uint32)u16CtrlValue);
      Diag_AcccForceIOControl_ForceCtrl(u32Command);
      Diag_u16IOCtrFreeTimer[Diag_nu16AcccActualReqCtrFree]=Diag_nu16IOCtrFreeTime;
      Diag_u8IOCtrFlag[Diag_nu16AcccActualReqCtrFree] = True;
  }
  else
  {
      /* Request contains invalid data - send negative response! */
      DescSetNegResponse(kDescNrcRequestOutOfRange);  
  }
  
  pMsgContext->resData[0]=0x03U;
  pMsgContext->resData[1]=pMsgContext->reqData[0];
  pMsgContext->resDataLen=2U;

  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescControl_ResetPassengerTempActuator (Service request header:$2F $63 $12 $0 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescControl_ResetPassengerTempActuator(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */
  #if 0
  Diag_MacForceIOControl_ForceCtrl(Diag_nu32MacPosPsNormal);
  Diag_u8IOCtrFlag[Diag_nu16MacPosPsCtrFree] = False;
  
  pMsgContext->resData[0] = 0x00; /*returnControlToECU*/
  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 1;
  #endif
  DescSetNegResponse(kDescNrcRequestOutOfRange);
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescControlPassengerTempActuator (Service request header:$2F $63 $12 $3 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescControlPassengerTempActuator(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Dummy example how to access the request data. */
  /* Assumming the FIRST DATA byte contains important data which has to be less than a constant value. */

  #if 0
  uint16 u16CtrlValue;
  uint32 u32Command;
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */
  
  u16CtrlValue= pMsgContext->reqData[0];
  u16CtrlValue<<=2; /*10 bit AD*/
  u32Command = Diag_nu32MacPosPsCtr|((uint32)u16CtrlValue);
  Diag_MacForceIOControl_ForceCtrl(u32Command);
  Diag_u16IOCtrFreeTimer[Diag_nu16MacPosPsCtrFree]=Diag_nu16IOCtrFreeTime;
  Diag_u8IOCtrFlag[Diag_nu16MacPosPsCtrFree] = True;
  pMsgContext->resData[0]=0x03U;
  pMsgContext->resData[1]=pMsgContext->reqData[0];
  pMsgContext->resDataLen=2U;
  
#endif
  DescSetNegResponse(kDescNrcRequestOutOfRange);
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescControl_ResetTelltalePWMDutyControl (Service request header:$2F $63 $1C $0 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescControl_ResetTelltalePWMDutyControl(DescMsgContext* pMsgContext)
{
	#if 0
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */
   /*Led1 PWM,Led2 PWM,Led3 PWM reset to normal control*/
  Diag_DimForceIOControl_ForceCtrl(Diag_nu32LedPWMNormal);  
  Diag_u8IOCtrFlag[Diag_nu16LedPWMCtrFree] = False;

  pMsgContext->resData[0]=0x00;
  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 1;
  #endif
  DescSetNegResponse(kDescNrcRequestOutOfRange);
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescControlTelltalePWMDutyControl (Service request header:$2F $63 $1C $3 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescControlTelltalePWMDutyControl(DescMsgContext* pMsgContext)
{ 
	#if 0
  uint16 u16CtrlValue;
  uint32 u32Command;
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Dummy example how to access the request data. */
  /* Assumming the FIRST DATA byte contains important data which has to be less than a constant value. */
  if(pMsgContext->reqData[0] <= 100)
  {
    /* Received data is in range process further. */
    /* Dummy example of how to write the response data. */
    u16CtrlValue=(uint16)pMsgContext->reqData[0];
    u32Command = Diag_nu32LedPWMReqCtr|(u16CtrlValue|0x0100);/*Led1 PWM*/
    Diag_DimForceIOControl_ForceCtrl(u32Command);
    u32Command = Diag_nu32LedPWMReqCtr|(u16CtrlValue|0x0200);/*Led2 PWM*/
    Diag_DimForceIOControl_ForceCtrl(u32Command);    
    u32Command = Diag_nu32LedPWMReqCtr|(u16CtrlValue|0x0400);/*Led3 PWM*/
    Diag_DimForceIOControl_ForceCtrl(u32Command);        
    pMsgContext->resData[0]=0x03;
    pMsgContext->resData[1]=pMsgContext->reqData[0];
    pMsgContext->resDataLen=2;
    Diag_u16IOCtrFreeTimer[Diag_nu16LedPWMCtrFree] = Diag_nu16IOCtrFreeTime;
    Diag_u8IOCtrFlag[Diag_nu16LedPWMCtrFree] = True;
  }
  else
  {
    /* Request contains invalid data - send negative response! */
    DescSetNegResponse(kDescNrcRequestOutOfRange);
  }
  #endif
  DescSetNegResponse(kDescNrcRequestOutOfRange);
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescStartSetUserSettingToDefalut (Service request header:$31 $1 $63 $F0 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescStartSetUserSettingToDefalut(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Dummy example how to access the request data. */
  /* Assumming the FIRST DATA byte contains important data which has to be less than a constant value. */

    /* Received data is in range process further. */
    /* Dummy example of how to write the response data. */
    Diag_MmiForceIOControl_ForceCtrl(0x01A10000u);
    pMsgContext->resData[0]=0x04u;/*sucessful*/
    pMsgContext->resDataLen =1u;
    /* User service processing finished. */
    DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescStartECUSelftest (Service request header:$31 $1 $DF $F0 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescStartECUSelftest(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Dummy example how to access the request data. */
  /* Assumming the FIRST DATA byte contains important data which has to be less than a constant value. */
    DescForceRcrRpResponse();
    Diag_boSelfTestReq = True;
    Diag_SelfTestRoutineTimer = Diag_SelfTestTimeCfg1;
    /* User service processing finished. */
    //DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescControl_DTC_Setting_onControlDTCSetting (Service request header:$85 $1 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescControl_DTC_Setting_onControlDTCSetting(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Contains no response data */
  /* User service processing finished. */

  uint16 u16Engine,u16EngSpdValid;

  u16Engine = Diag_u16EngSpd;
  u16EngSpdValid = Diag_u16EngSpdValid;/*0 is valid*/
  
  if((u16EngSpdValid == 0U)&&(u16Engine>0U)&&(u16Engine!=0xFFFFU)&&(u16Engine!=0xFFFEU))/*Engine is running*/
  {
	  /* Request contains invalid data - send negative response! */
	  DescSetNegResponse(kDescNrcConditionsNotCorrect);
  }
  else
  { 
      Diag_DtcForceIOControl_ForceCtrl((Diag_nu32DTCSettingCtr|On));
  }
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescControl_DTC_Setting_offControlDTCSetting (Service request header:$85 $2 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescControl_DTC_Setting_offControlDTCSetting(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Contains no response data */
  /* User service processing finished. */
  uint16 u16Engine,u16EngSpdValid;

  u16Engine = Diag_u16EngSpd;
  u16EngSpdValid = Diag_u16EngSpdValid;/*0 is valid*/
  
  if((u16EngSpdValid == 0U)&&(u16Engine>0U)&&(u16Engine!=0xFFFFU)&&(u16Engine!=0xFFFEU))/*Engine is running*/
  {
	  /* Request contains invalid data - send negative response! */
	  DescSetNegResponse(kDescNrcConditionsNotCorrect);
  }
  else
  { 
      Diag_DtcForceIOControl_ForceCtrl((Diag_nu32DTCSettingCtr|Off));
  }
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescPostResethardReset (Service request header:$11 $1 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - status:
 *       - Shows the status of the process accomplishment. Can be: kDescPostHandlerStateOk or kDescPostHandlerStateNegResSent or/and kDescPostHandlerStateTxFailed.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called (within this post-handler or
 * later before a main-handler is called).
 *   - The function "DescSetNegResponse" may not be called (within this post-handler or
 * later before at least a pre-handler is called).
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescPostResethardReset(vuint8 status)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
    /* Avoid warnings */
  DESC_CONTEXT_PARAM_DUMMY_USE;

  /* Check if this service may be executed (condition checks). This one is dummy check please remove it!. */
  if(status == kDescPostHandlerStateOk)
  {
    /* Do post processing since everything ran without errors (the positive response (process finalization)
     * was successfully sent (closed). 
     */
     Diag_biHardReset = True;
  }
  else
  {
    /* Optional code if the failure reason is from importance. */

    /* The ... */
    if((status & kDescPostHandlerStateNegResSent) != 0)
    {
      /* ... negative response ... */
    }
    else
    {
      /* ... positive response ... */
    }

    if((status & kDescPostHandlerStateTxFailed) != 0)
    {
      /* ... transmission has failed. */
    }
    else
    {
      /* ... transmission has been successfully accomplished. */
    }
  }
;
}


/*  ********************************************************************************
 * Function name:ApplDescPostResetsoftReset (Service request header:$11 $3 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - status:
 *       - Shows the status of the process accomplishment. Can be: kDescPostHandlerStateOk or kDescPostHandlerStateNegResSent or/and kDescPostHandlerStateTxFailed.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called (within this post-handler or
 * later before a main-handler is called).
 *   - The function "DescSetNegResponse" may not be called (within this post-handler or
 * later before at least a pre-handler is called).
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescPostResetsoftReset(vuint8 status)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
    /* Avoid warnings */
  DESC_CONTEXT_PARAM_DUMMY_USE;

  /* Check if this service may be executed (condition checks). This one is dummy check please remove it!. */
  if(status == kDescPostHandlerStateOk)
  {
    /* Do post processing since everything ran without errors (the positive response (process finalization)
     * was successfully sent (closed). 
     */
    Diag_biSoftReset = True;
  }
  else
  {
    /* Optional code if the failure reason is from importance. */

    /* The ... */
    if((status & kDescPostHandlerStateNegResSent) != 0)
    {
      /* ... negative response ... */
    }
    else
    {
      /* ... positive response ... */
    }

    if((status & kDescPostHandlerStateTxFailed) != 0)
    {
      /* ... transmission has failed. */
    }
    else
    {
      /* ... transmission has been successfully accomplished. */
    }
  }
;
}


/* ********************************************************************************
 * Function name:ApplDescOnCommunicationDisable
 * Description: Notification function that the communication has been disabled.
 * Returns:  none
 * Parameter(s):none
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ******************************************************************************** */
void DESC_API_CALLBACK_TYPE ApplDescOnCommunicationDisable(void)
{
  /*<<TBD>> Remove this comment once you have completely implemented this function!!!*/
  /* The requested group of messages will no more be sent onto the communication bus. */
}

/* ********************************************************************************
 * Function name:ApplDescOnCommunicationEnable
 * Description: Notification function that the communication has been restored.
 * Returns:  none
 * Parameter(s):none
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ******************************************************************************** */
void DESC_API_CALLBACK_TYPE ApplDescOnCommunicationEnable(void)
{
  /*<<TBD>> Remove this comment once you have completely implemented this function!!!*/
  /* The requested group of messages will be able to be sent onto the communication bus. */
}

/* Check the communication control activity */
/* ********************************************************************************
 * Function name:ApplDescCheckCommCtrl
 * Description:Check if the requested communication manipulation is possible to be performed by the ECU.
 * Returns:  nothing
 * Parameter(s):
 *   - iContext:
 *       - Diagnostic request handle used only in multi-context system (kDescNumContexts > 1).
 *       - Access type: read
 *   - commControlInfo->subNetTxNumber:
 *       - The application shall use this parameter to decied on which physical channels the communiaction will be manipulated.
 *       - Access type: read
 *   - commControlInfo->commCtrlChannel:
 *       - The application determines on which channel the communication will be manipulated (kDescCommControlCanCh01 - kDescCommControlCanCh14).
 *       - Access type: write
 *   - commControlInfo->rxPathState:
 *       - Activity type: kDescCommControlStateEnable - enables the communication; kDescCommControlStateDisable - disables it.
 *       - Access type: read
 *   - commControlInfo->txPathState:
 *       - Activity type: kDescCommControlStateEnable - enables the communication; kDescCommControlStateDisable - disables it.
 *       - Access type: read
 *   - commControlInfo->msgTypes:
 *       - Message group: kDescCommControlMsgAppl - application; kDescCommControlMsgNm - NM; 
 *       - Access type: read
 *   - commControlInfo->reqCommChannel:
 *       - The current CAN channel on which the CommControl request is received.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - Call "DescCommCtrlChecked" (here or later) to confirm the check.
 *   - Call "DescSetNegResponse" to reject the service.
 ******************************************************************************** */
void DESC_API_CALLBACK_TYPE ApplDescCheckCommCtrl(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST DescOemCommControlInfo *commControlInfo)
{
  /*<<TBD>> Remove this comment once you have completely implemented this function!!!*/

#if defined (DESC_ENABLE_COMM_CTRL_SUBNET_SUPPORT)
  switch(commControlInfo->subNetNumber)
  {
    case kDescCommControlSubNetNumAll:/* Enable/Disable all comm channels (CAN, LIN, etc.)*/
      /* Nothing to do - later the ApplDescSetCommMode will enable/disbale the LIN channels if needed. */
      break;
    case kDescCommControlSubNetNumRx:/* Enable/Disable only the request RX comm channel (CAN)*/
      /* Nothing to do - CANdesc handles the CAN channels */
      break;
    default:
      /* Dispatch subnetworks */
      /* Assumed subnet to CAN mapping: 
       * SubNet 1: LIN 
       * SubNet 2: CAN1 
       * SubNet 3: CAN2 
       */
      switch(commControlInfo->subNetNumber)
      {
        case kDescCommControlSubNetNum01:
          /* LIN network */
          commControlInfo->commCtrlChannel = kDescCommControlCanChNone;
          break;
/* The part is only needed if a multi CAN system is designed !!! */
# if defined(DESC_ENABLE_MULTI_CHANNEL_SUPPORT)
        case kDescCommControlSubNetNum02:
          /* CAN1 */
          commControlInfo->commCtrlChannel = kDescCommControlCanCh01;
          break;
        case kDescCommControlSubNetNum03:
          /* CAN2 */
          commControlInfo->commCtrlChannel = kDescCommControlCanCh02;
          break;
# endif
        default:
          /* Subnet numbers out of range */
          DescSetNegResponse(DESC_CONTEXT_PARAM_FIRST kDescNrcRequestOutOfRange);
          break;
      }
  }
#endif
  /* Confirm the communication status will be accepted. 
   * This can be done later by storing the iContext parameter (if exists) globaly to be able to give the correct acknowledgment.
   */
  DescCommCtrlChecked(DESC_CONTEXT_PARAM_ONLY);
}

#if defined (DESC_ENABLE_COMM_CTRL_SUBNET_SUPPORT)
/* ********************************************************************************
 * Function name:ApplDescSetCommMode
 * Description:Manipulate application specific channels (LIN, MOST, etc.)
 * Returns:  nothing
 * Parameter(s):
 *   - commControlInfo->subNetTxNumber:
 *       - The application shall use this parameter to decied on which physical channels the communiaction will be manipulated.
 *       - Access type: read
 *   - commControlInfo->commCtrlChannel:
 *       - The application determines on which channel the communication will be manipulated (kDescCommControlCanCh01 - kDescCommControlCanCh14).
 *       - Access type: write
 *   - commControlInfo->rxPathState:
 *       - Activity type: kDescCommControlStateEnable - enables the communication; kDescCommControlStateDisable - disables it.
 *       - Access type: read
 *   - commControlInfo->txPathState:
 *       - Activity type: kDescCommControlStateEnable - enables the communication; kDescCommControlStateDisable - disables it.
 *       - Access type: read
 *   - commControlInfo->msgTypes:
 *       - Message group: kDescCommControlMsgAppl - application; kDescCommControlMsgNm - NM; 
 *       - Access type: read
 *   - commControlInfo->reqCommChannel:
 *       - The current CAN channel on which the CommControl request is received.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ******************************************************************************** */
void DESC_API_CALLBACK_TYPE ApplDescSetCommMode(DescOemCommControlInfo *commControlInfo)
{
  switch(commControlInfo->subNetNumber)
  {
    case kDescCommControlSubNetNumAll:/* Enable/Disable all comm channels (CAN, LIN, etc.)*/
      /* !!! Process application specific channels (e.g. LIN) CAN are already enabled/disabled by CANdesc */
      break;
    case kDescCommControlSubNetNumRx:/* Enable/Disable only the request RX comm channel (CAN)*/
      /* Nothing to do - CANdesc handles the CAN channels */
      break;
    default:
      /* Dispatch subnetworks */
      /* Assumed subnet to CAN mapping: 
       * SubNet 1: LIN 
       * SubNet 2: CAN1 
       * SubNet 3: CAN2 
       */
      switch(commControlInfo->subNetNumber)
      {
        case kDescCommControlSubNetNum01:
          /* LIN network */
          /* !!! Process application specific channels (e.g. LIN)*/
          break;
        case kDescCommControlSubNetNum02:          /* CAN1 */
        case kDescCommControlSubNetNum03:          /* CAN2 */
          /* Nothing to do - CANdesc handles all CANs */
          break;
        default:break;
      }
  }
}
#endif

#if defined (DESC_ENABLE_RX_COMM_CONTROL)
/* ********************************************************************************
 * Function name:ApplDescSetCommModeOnRxPath
 * Description: Manipulates only the RX path on CAN. For the other networks (if any) such LIN, MOST, etc. reffer to the
 *              ApplDescSetCommMode API.
 * Returns:  nothing
 * Parameter(s):
 *   - commControlInfo->subNetTxNumber:
 *       - The application shall use this parameter to decied on which physical channels the communiaction will be manipulated.
 *       - Access type: read
 *   - commControlInfo->commCtrlChannel:
 *       - The application determines on which channel the communication will be manipulated (kDescCommControlCanCh01 - kDescCommControlCanCh14).
 *       - Access type: write
 *   - commControlInfo->rxPathState:
 *       - Activity type: kDescCommControlStateEnable - enables the communication; kDescCommControlStateDisable - disables it.
 *       - Access type: read
*   - commControlInfo->rxPathState: - irrelevant for this API since it processes only the RX path!!!
 *       - Activity type: kDescCommControlStateEnable - enables the communication; kDescCommControlStateDisable - disables it.
 *       - Access type: read
 *   - commControlInfo->msgTypes:
 *       - Message group: kDescCommControlMsgAppl - application; kDescCommControlMsgNm - NM; 
 *       - Access type: read
 *   - commControlInfo->reqCommChannel:
 *       - The current CAN channel on which the CommControl request is received.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ******************************************************************************** */
void DESC_API_CALLBACK_TYPE ApplDescSetCommModeOnRxPath(DescOemCommControlInfo *commControlInfo)
{
  if((commControlInfo->rxPathState & kDescCommControlStateEnable) != 0)
  {
    /* _DrvCanSetRxOnlineMode(commControlInfo.commCtrlChannel, g_descCommControlInfo.msgTypes); */
    if((commControlInfo->msgTypes&0x01)== 0x01) /*Application message,modify by LT 20160709 */
    {
        DIAG_au8Array[DIAG_nu8AppRxDisable] = False;
    }
  }
  else
  {
    /* _DrvCanSetRxOfflineMode(commControlInfo.commCtrlChannel, g_descCommControlInfo.msgTypes); */
    if((commControlInfo->msgTypes&0x01)== 0x01) /*Application message,modify by LT 20160709 */
    {
        DIAG_au8Array[DIAG_nu8AppRxDisable] = True;
    }

  }
}
#endif

/*  ********************************************************************************
 * Function name:ApplDescCheckSessionTransition
 * Description:Check if the given session transition is allowed or your ECU is currently not
 * able to perform it.
 * Returns:  nothing
 * Parameter(s):
 *   - newState:
 *       - Contains the new state in which the state group will be set.
 *       - Access type: read
 *   - formerState:
 *       - Contains the current state of the state group.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescSessionTransitionChecked" may be called.
 *   - The function "DescSetNegResponse" may be called.
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescCheckSessionTransition(DescStateGroup newState, DescStateGroup formerState)
{
  uint16 u16Engine,u16EngSpdValid;

  u16Engine = Diag_u16EngSpd;
  u16EngSpdValid = Diag_u16EngSpdValid;/*0 is valid*/
  
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
     /* Avoids warnings */
  DESC_IGNORE_UNREF_PARAM(newState);
  DESC_IGNORE_UNREF_PARAM(formerState);
  /* Just showing how to reject session transition if necessary. 
   * The negative response code may be other depending on the rejection reason.
   * This can be done later, but just store the iContext parameter (if exists) globaly to be able to give the correct acknowledgment. 
   */
  //DescSetNegResponse(DESC_CONTEXT_PARAM_FIRST kDescNrcConditionsNotCorrect);
  /* Confirm the session will be accepted. 
   * This can be done later, but just store the iContext parameter (if exists) globaly to be able to give the correct acknowledgment.
   */
  if(newState == kDescStateSessionProgramming)
  { 
      if((u16EngSpdValid == 0U)&&(u16Engine>0U)&&(u16Engine!=0xFFFFU)&&(u16Engine!=0xFFFEU))/*Engine is running*/
      {
    	  /* Request contains invalid data - send negative response! */
    	  DescSetNegResponse(kDescNrcConditionsNotCorrect);
      }
      else
      {
          Boot_ReprogramCallBack();/*BY ZSC,160521*/
          //Diag_biHardReset = True;
          //DescSetNegResponse(DESC_CONTEXT_PARAM_FIRST kDescNrcResponsePending);
      }
  }
  
  if((newState == kDescStateSessionDefault)||(newState == kDescStateSessionExtendedDiagnostic))
  {
        DescSetStateSecurityAccess(kDescStateSecurityAccessLocked);/*Add by LT,20160524,accroding to the Geely Spec 3.2,page 30*/
  }
  DescSessionTransitionChecked(DESC_CONTEXT_PARAM_ONLY);
;
}


#if defined (DESC_ENABLE_REPORT_ATT_CNTR_STATE)
/* ********************************************************************************
 * Function name:ApplDescSecurityAccessOnAttCntrChanged
 * Description: Once the invalid key attempt counter has been changed, this event is triggered.
 * Returns:  Random value
 * Parameter(s):
 *   - iContext:(not available in single context systems)
 *       - Use this call-back handle for all API which need it.
 *       - Access type: read
 *   - chgEv: specifies the reason for hte counter change
 *       - You can use this information in order to perform special activities if needed.
 *       - Access type: read
 *   - newAttCounter: new attempt counter value
 *       - If required, you can store this value into NVM.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" is NOT allowed to be called.
 *   - The function "DescSetNegResponse" is NOT allowed to be called.
 ******************************************************************************** */
void ApplDescSecurityAccessOnAttCntrChanged(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST DescSecAccAttCtrChgEvType chgEv, vuint8 newAttCounter)
{
  switch(chgEv)
  {
    case kDescSecAccAttCtrChgOnTimeExpire:
      /* Event that the penalty time expired - do something if needed */
      break;
    case kDescSecAccAttCtrChgOnTooManyInvalidKeys:
      /* Event that too many invalid keys were received - do something if needed */
    case kDescSecAccAttCtrChgOnInvalidKey: /* fall through */
      /* Event that an invalid key received - do something if needed */
      break;
# if defined (DESC_ENABLE_ATT_CNTR_RESET_ON_KEY_OK)
    case kDescSecAccAttCtrChgOnValidKey:
      /* Event that a valid key is received - do something if needed */
      break;
# endif
# if defined(DESC_ENABLE_USE_ERR_CNTR_PROTECTION)
    case kDescSecAccAttCtrChgOnTooManySeedsWithoutKey:
      /* Event that too many seed requests without a send key were received - do something if needed */
    case kDescSecAccAttCtrChgOnSeedWithoutKey: /* fall through */
      /* Event that another seed request without a send key is received - do something if needed */
      break;
# endif
    case kDescSecAccAttCtrChgOnApplRequest:
      /* Event that "DescSetAttemptCounterValue" has changed the counter value.
       * Usually you shall ignore this event type, since it is triggered by the application, but
       * to have complete "OnChange" chain this event will be triggered.*/
      return; /* usually you shall skip updating NVM */
    case kDescSecAccAttCtrChgInvalid:
      /* Invalid event type shall never occur!!! */
    default: /* fall through */
      /* not a valid case - do assert */
      return;/* do not store anything */
  }

  /*
  Optionally you can still access the current (not yet changed) value of the counter */
  if ( (DescGetAttemptCounterValue(DESC_CONTEXT_PARAM_ONLY) == 0) &&
       (newAttCounter == 1) )
  {
    /* do something on very first increment of the counter */
  }


  /* Update the attempt counter in the NVM in all cases
  eepWrite(secAccessAttCntrHndl, newAttCounter);
  */
}
#endif

/******************************************************************************
* Name         :  SecM_ComputeKey  
* Called by    :  CheckKey
* Preconditions:  None
* Parameters   :  None
* Description  :  
******************************************************************************/
static vuint32 SecM_ComputeKey(void)
{
  uint32 tmpX; //tmpY;

  const uint8 u8Xor[4] = {0x65,0x67,0x77,0xE9};   
  uint8 u8Seed[4],u8Key[4],u8Cal[4],u8i;

  /*The calculation is provied by Geely*/
  SecM_Serializer(u8Seed, g_applDescSeedX);
  
  for(u8i = 0; u8i < 4; u8i++)
  {
        u8Cal[u8i] = u8Seed[u8i]^u8Xor[u8i];
  }

  u8Key[0] = ((u8Cal[3]&0x0F)<<4)|(u8Cal[3]&0xF0);
  u8Key[1] = ((u8Cal[1]&0x0F)<<4)|((u8Cal[0]&0xF0)>>4);
  u8Key[2] = (u8Cal[1]&0xF0)|((u8Cal[2]&0xF0)>>4);
  u8Key[3] = ((u8Cal[0]&0x0F)<<4)|(u8Cal[2]&0x0F);
  
  tmpX = DescMake32Bit(u8Key[0],u8Key[1],u8Key[2],u8Key[3]);
  
  
  return tmpX;
}

/******************************************************************************
* Name         :  SecM_Serializer  
* Called by    :  CheckKey
* Preconditions:  None
* Parameters   :  None
* Description  :  
******************************************************************************/
static void SecM_Serializer(DescMsg tgtPtr, vuint32 data)
{
  vuint8_least iter;
  iter = 4;
  while(iter != 0)
  {
    iter--;
    tgtPtr[iter] = (DescMsgItem)data;
    data >>= 8;
  }
}

/* ********************************************************************************
 * Function name:ApplDescSecurityAccessGetSeed
 * Description: Each time called must generate a different value (e.g. current free running timer value).
 * Returns:  Random value
 * Parameter(s):
 *   - iContext:(not available in single context systems)
 *       - Use this call-back handle for all API which need it.
 *       - Access type: read
 *   - securityLevel:
 *       - The current security level represented by the generated contsants (e.g kDescStateSecurityAccessLevel1e etc.).
 *       - Access type: read
 *   - seed:
 *       - A pointer where the generated seed must be written by the application.
 *       - Access type: write
 *   - seedLen:
 *       - The length of the written seed.
 *       - Access type: write
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" is NOT allowed to be called.
 *   - The function "DescSetNegResponse" is NOT allowed to be called.
 ******************************************************************************** */
void ApplDescSecurityAccessGetSeed(DescSecurityAccessContext* pDescSecurityAccessContext)
{
  /* Generate each time a random 64Bit value !!! 
   * Example:
   */
    uint16 SeedCalcu1;
    uint16 SeedCalcu2;
    
    srand(SeedCounter1);
    SeedCalcu1 = rand();
    srand(SeedCounter2);
    SeedCalcu2 = rand();
    g_applDescSeedX=((uint32)SeedCalcu1<<16)|SeedCalcu2;
    
  if((g_applDescSeedX == 0ul)||(g_applDescSeedX == 0xFFFFFFFFU))
  {
        g_applDescSeedX = 0x0016C0B0U;
  }

  /* MSB 32Bit*/
  SecM_Serializer(&(pDescSecurityAccessContext->dataPtr[0]), g_applDescSeedX);

  /*Only the use the g_applDescSeedX*/
  
  /* LSB 32Bit*/
  SecM_Serializer(&(pDescSecurityAccessContext->dataPtr[4]), g_applDescSeedY);

  /* Currently the example will calculate always a 8 Byte SEED */
  /* dataLen parameter is already initialized with the seed length from the CDD file */
  /* pDescSecurityAccessContext->dataLen = 8;*/

  /* Call this function to confirm the process end now or outside of this call-back */
  DescSecurityAccessSeedReady(DESC_CONTEXT_PARAM_WRAPPER_ONLY(pDescSecurityAccessContext->iContext));
}

/* ********************************************************************************
 * Function name:ApplDescSecurityAccessCheckKey
 * Description: The application must validate the received security key.
 * Returns:  Random value
 * Parameter(s):
 *   - iContext:(not available in single context systems)
 *       - Use this call-back handle for all API which need it.
 *       - Access type: read
 *   - securityLevel:
 *       - The current security level represented by the generated contsants (e.g kDescStateSecurityAccessLevel1e etc.).
 *       - Access type: read
 *   - key:
 *       - A pointer where the received key must be read from by the application.
 *       - Access type: read
 *   - keyLength:
 *       - The length of the received key.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" is NOT allowed be called.
 *   - The function "DescSetNegResponse" is NOT allowed be called. 
 ******************************************************************************** */
void ApplDescSecurityAccessCheckKey(DescSecurityAccessContext* pDescSecurityAccessContext)
{
   /* The size of this array may vary and depends on the security key definition in the CDD file. */
  vuint32 tmpKey;     /* Store Key on the stack, invisible for extern access */

  /* Key is OK */
  pDescSecurityAccessContext->status = kDescSaStatusOk;

  /* Calculate the Key */
  tmpKey = SecM_ComputeKey();

  /* Compare results with Key from tester */
  if (tmpKey != DescMake32Bit(pDescSecurityAccessContext->dataPtr[0],
                              pDescSecurityAccessContext->dataPtr[1],
                              pDescSecurityAccessContext->dataPtr[2],
                              pDescSecurityAccessContext->dataPtr[3])
      )
  {
    /* Key is INVALID */
    pDescSecurityAccessContext->status = kDescSaStatusNok;
  }
  /* Call this function to confirm the process end now or outside of this call-back */
  DescSecurityAccessKeyChecked(DESC_CONTEXT_PARAM_WRAPPER_ONLY(pDescSecurityAccessContext->iContext));
}

/*  ********************************************************************************
 * Function name:ApplDescReadProgrammingCounter (Service request header:$22 $2 $0 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadProgrammingCounter(DescMsgContext* pMsgContext)
{
  uint8 u8Ret;
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */
  u8Ret = Diag_u8ReadEEDData(ProgrammingCounterAddr,&pMsgContext->resData[0],4u); /*At least read 4*/

  if(u8Ret!=0u)
  {
    pMsgContext->resData[0] = 0u;
  }

  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 1;
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescReadProgrammingAttempCounter (Service request header:$22 $2 $1 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadProgrammingAttempCounter(DescMsgContext* pMsgContext)
{
  uint8 u8Ret;
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */
  u8Ret = Diag_u8ReadEEDData(ProgrammingAttemptCounterAddr,&pMsgContext->resData[0],4u); /*At least read 4*/

  if(u8Ret!=0u)
  {
    pMsgContext->resData[0] = 0u;
  }
  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 1;
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescReadDriverTempActuator (Service request header:$22 $63 $0 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadDriverTempActuator(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */
  uint16 u16AdValue;
  
  //DCM_enGetU16Value(DCM_nu16AdValueMixDr,u16AdValue);
  u16AdValue = Diag_u16MixMotorFbAdValueDr;
  pMsgContext->resData[0] = (uint8)(u16AdValue>>2);

  //pMsgContext->resData[0] = (uint8)(Diag_u16MixMotorFbAdValueDr>>2);
  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 1;
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescReadInCarTemperature (Service request header:$22 $63 $1 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadInCarTemperature(DescMsgContext* pMsgContext)
{
  uint16 u16InCarTemp;
  uint8 u8StatusByte1,u8StatusByte2,u8Index;
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */
  //u8Index = DTC_nInCarGnd;
  //Diag_u8ReadDTCStatus(&u8StatusByte1,&u8Index);
  //u8Index = DTC_nInCarBat;
  //Diag_u8ReadDTCStatus(&u8StatusByte2,&u8Index);
  
  if((VICT_u16GetValidState(VICT_nu16HeadZoneTempL) == 1u)\
      && (VICT_u16GetValidState(VICT_nu16HeadZoneTempR) == 1u))
  {
      u16InCarTemp = (VICT_u16GetValue(VICT_nu16HeadZoneTempL) + VICT_u16GetValue(VICT_nu16HeadZoneTempL))/2;
      u16InCarTemp = ApplDescAppToDiagTempFormat(u16InCarTemp);
  }
  else
  {
      u16InCarTemp = 0xFFFF;/*Invalid value*/
  }
    
  //if(((u8StatusByte1&StatusTestFail)==StatusTestFail)||((u8StatusByte2&StatusTestFail)==StatusTestFail))
  //{
     //u16InCarTemp = 0xFFFF;/*Invalid value*/
  //}
  //else
  //{    
      //u16InCarTemp = Diag_u16IctSensorTemp(&u16InCarTemp);
      //u16InCarTemp = ApplDescAppToDiagTempFormat(u16InCarTemp);
  //}
 
  pMsgContext->resData[0] = (uint8)u16InCarTemp;
  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 1;
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescReadAmbientTemperature (Service request header:$22 $63 $2 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadAmbientTemperature(DescMsgContext* pMsgContext)
{
  uint16 u16OatTemp;
  uint8 u8StatusByte1,u8StatusByte2,u8Index;
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */
  u8Index = DTC_nOatGnd;
  Diag_u8ReadDTCStatus(&u8StatusByte1,&u8Index);
  u8Index = DTC_nOatBat;  
  Diag_u8ReadDTCStatus(&u8StatusByte2,&u8Index);
  

  if(((u8StatusByte1&StatusTestFail)==StatusTestFail)||((u8StatusByte2&StatusTestFail)==StatusTestFail))
  {
     u16OatTemp = 0xFFFF;/*Invalid value*/
  }
  else
  {
      u16OatTemp = Diag_u16OatSensorTemp;
      u16OatTemp = ApplDescAppToDiagTempFormat(u16OatTemp);
  }
 
  pMsgContext->resData[0] = (uint8)u16OatTemp;
  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 1;
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescReadEvapTemperature (Service request header:$22 $63 $3 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadEvapTemperature(DescMsgContext* pMsgContext)
{
  uint16 u16EvapTemp;
  uint8 u8StatusByte1,u8StatusByte2,u8Index;
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */
  u8Index = DTC_nEvapGnd;
  Diag_u8ReadDTCStatus(&u8StatusByte1,&u8Index);
  u8Index = DTC_nEvapBat;  
  Diag_u8ReadDTCStatus(&u8StatusByte2,&u8Index);
  if(((u8StatusByte1&StatusTestFail)==StatusTestFail)||((u8StatusByte2&StatusTestFail)==StatusTestFail))
  {
     u16EvapTemp = 0xFFFF;/*Invalid value*/   
  }
  else
  {
      u16EvapTemp = Diag_u16EvapSensorTemp;
      u16EvapTemp = ApplDescAppToDiagTempFormat(u16EvapTemp);    
  }
 
  pMsgContext->resData[0] = (uint8)u16EvapTemp;
  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 1;
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescReadInCarAirQuanlityStatus (Service request header:$22 $63 $6 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadInCarAirQuanlityStatus(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */

/*  
0x00:ÓÅ--> PM2.5<35
0x01:Á¼--> PM2.5<75 And PM2.5¡Ý35
0x02:Çá¶ÈÎÛÈ¾--> PM2.5<115 And PM2.5¡Ý75
0x03:ÖÐ¶ÈÎÛÈ¾--> PM2.5<150 And PM2.5¡Ý115
0x04:ÖØ¶ÈÎÛÈ¾--> PM2.5<250 And PM2.5¡Ý150
0x05:ÑÏÖØÎÛÈ¾--> PM2.5<999 And PM2.5¡Ý250
0x06~0xFE:Reserved
0xFF: Invalid 
*/
  
  if(Diag_u8InCarAirQuanlityStatus <= 0x05)
  {
    pMsgContext->resData[0] = Diag_u8InCarAirQuanlityStatus;
  }
  else
  {
    pMsgContext->resData[0] = 0xFFU;
  }
  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 1;
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescReadInCarAirQuanlityValue (Service request header:$22 $63 $7 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadInCarAirQuanlityValue(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */
  pMsgContext->resData[0] = (uint8)(Diag_u16InCarAirQuanlityValue>>8U);
  pMsgContext->resData[1] = (uint8)(Diag_u16InCarAirQuanlityValue);
  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 2;
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescReadLoopmode (Service request header:$22 $63 $8 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadLoopmode(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */
  if(Diag_u8RfaDisplay == 0)/*Fresh*/
  {
    pMsgContext->resData[0] = 1;
  }
  else
  {
    pMsgContext->resData[0] = 0;    
  }
  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 1;
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescReadIONControl (Service request header:$22 $63 $9 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadIONControl(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */
  pMsgContext->resData[0] = Diag_u8IONCtrState;
  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 1;
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescReadACWorkingState (Service request header:$22 $63 $A )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadACWorkingState(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */

  if(Diag_u8MmiModeState<=0x02)
  {
     pMsgContext->resData[0] = Diag_u8MmiModeState;
  }
  else if((Diag_u8MmiModeState ==0x03U)||(Diag_u8MmiModeState ==0x04U) )/*MMI_nSysStateDefrost*//*MMI_nSysStateMaxAc*/
  {
     pMsgContext->resData[0] = 0x01; /*Manual*/
  }
  else /*error */
  {
     pMsgContext->resData[0] = 0x01; /*Manual*/
  }

  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 1;
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescReadBlower_Level (Service request header:$22 $63 $B )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadBlower_Level(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */
  pMsgContext->resData[0] = Diag_u8BctlDisplay;
  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 1;
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescReadModeActuator (Service request header:$22 $63 $C )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadModeActuator(DescMsgContext* pMsgContext)
{
  uint8 u8ModeState;
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */
    switch(Diag_u8AirdDisplay)
    {
        case 0: /*face*/
        u8ModeState = 1;   
        break;
        case 1:/*bilevel*/
        u8ModeState = 3;                   
        break;
        case 2: /*foot*/
        u8ModeState = 2;   
        break;
        case 3:/*mixed*/
        u8ModeState = 4;                   
        break;
        case 4:/*defrost*/
        u8ModeState = 5;  
        break;
        default:
        u8ModeState = 1;   
        break;
    }  
  pMsgContext->resData[0] =  u8ModeState;  
  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 1;
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescReadDefrostState (Service request header:$22 $63 $D )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadDefrostState(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */
  if(Diag_u8MmiModeState == 0x03U)/*MMI_nSysStateDefrost*/
  {
      pMsgContext->resData[0] = 0x01U;
  }
  else
  {
      pMsgContext->resData[0] = 0x00U;  
  }
  
  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 1;
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescReadRearDefrostControl(Service request header:$22 $63 $E )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadRearDefrostControl(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */
  
#if 0
  if(0)//(Diag_u8RdcDisplay == 0x01)
  {
    pMsgContext->resData[0] = On;
  }
  else
  {
    pMsgContext->resData[0] = Off;    
  }
  #endif
  DescSetNegResponse(kDescNrcRequestOutOfRange);
  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 1;
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescReadCompressorControl (Service request header:$22 $63 $F )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadCompressorControl(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */
  pMsgContext->resData[0] = Diag_u16AcccRequest;
  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 1;
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescReadMAXA_CState (Service request header:$22 $63 $10 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadMAXA_CState(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */

  
  if(Diag_u8MmiModeState == 0x04U)/*MMI_nSysStateMaxAc*/
  {
    pMsgContext->resData[0] = 0x01U;
  }
  else
  {
    pMsgContext->resData[0] = 0x00U;
  }
  
  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 1;
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescReadDual_state (Service request header:$22 $63 $11 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadDual_state(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */

  if(Diag_u8DualState == True)
  {
    pMsgContext->resData[0] = 0x01U;
  }
  else
  {
    pMsgContext->resData[0] = 0x00U;
  }
  
  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 1;
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescReadPassengerTempActuator (Service request header:$22 $63 $12 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadPassengerTempActuator(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */
  #if 0
  uint16 u16AdValue;
  
  //DCM_enGetU16Value(DCM_nu16AdValueMixPs,u16AdValue);
  u16AdValue = Diag_u16MixMotorFbAdValuePs;
  pMsgContext->resData[0] = (uint8)(u16AdValue>>2);
  
  //pMsgContext->resData[0] = (uint8)(Diag_u16MixMotorFbAdValuePs>>2U);
  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 1;
  #endif
  DescSetNegResponse(kDescNrcRequestOutOfRange);
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescReadRecirculationActuator (Service request header:$22 $63 $13 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadRecirculationActuator(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */

  uint16 u16AdValue;
  
  //DCM_enGetU16Value(DCM_nu16AdValueRfa,u16AdValue);
  u16AdValue = Diag_u16RfaMotorFbAdValue;
  pMsgContext->resData[0] = (uint8)(u16AdValue>>2);
  //pMsgContext->resData[0] = (uint8)(Diag_u16RfaMotorFbAdValue>>2U);
  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 1;
  /* User service processing finished. */
  DescProcessingDone();
}

/*  ********************************************************************************
 * Function name:ApplDescReadDriver_side_Sunload_Value (Service request header:$22 $63 $15 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadDriver_side_Sunload_Value(DescMsgContext* pMsgContext)
{
  uint16 u16SunValueDr;

  Rte_Call_IoHwAd_IoHwAd_ReadAd_DriverSolarSensor_Read(&u16SunValueDr);
  
  if(u16SunValueDr<=0x7D0)/*2000W*/
  {
      pMsgContext->resData[0] = (uint8)(u16SunValueDr>>8U);
      pMsgContext->resData[1] = (uint8)(u16SunValueDr);
  }
  else if((u16SunValueDr==0xFFFF)||(u16SunValueDr==0xFFFE))/*miss message*/
  {
      /*Invalid value*/
      pMsgContext->resData[0] = 0xFF;
      pMsgContext->resData[1] = 0xFF;    
  }
  else
  {
      pMsgContext->resData[0] = 0x07;
      pMsgContext->resData[0] = 0xD0;      
  }
  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 2;
  /* User service processing finished. */
  DescProcessingDone();
}

/*  ********************************************************************************
 * Function name:ApplDescReadPassenegr_side_Sunload_Value (Service request header:$22 $63 $16 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadPassenegr_side_Sunload_Value(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */
  uint16 u16SunValuePs;

  Rte_Call_IoHwAd_IoHwAd_ReadAd_PassengerSolarSensor_Read(&u16SunValuePs);// = Diag_u16SunValuePs;
  u16SunValuePs=0xFFFF;
  if(u16SunValuePs<=0x7D0)/*2000W*/
  {
      pMsgContext->resData[0] = (uint8)(u16SunValuePs>>8U);
      pMsgContext->resData[1] = (uint8)(u16SunValuePs);
  }
  else if((u16SunValuePs==0xFFFF)||(u16SunValuePs==0xFFFE))/*miss message*/
  {
    /*Invalid value*/
      pMsgContext->resData[0] = 0xFF;
      pMsgContext->resData[1] = 0xFF;    
  }
  else
  {
      pMsgContext->resData[0] = 0x07;
      pMsgContext->resData[0] = 0xD0;      
  }
  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 2;
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescReadOutSideAirQuanlityStatus (Service request header:$22 $63 $17 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadOutSideAirQuanlityStatus(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */

/*  
0x00:ÓÅ--> PM2.5<35
0x01:Á¼--> PM2.5<75 And PM2.5¡Ý35
0x02:Çá¶ÈÎÛÈ¾--> PM2.5<115 And PM2.5¡Ý75
0x03:ÖÐ¶ÈÎÛÈ¾--> PM2.5<150 And PM2.5¡Ý115
0x04:ÖØ¶ÈÎÛÈ¾--> PM2.5<250 And PM2.5¡Ý150
0x05:ÑÏÖØÎÛÈ¾--> PM2.5<999 And PM2.5¡Ý250
0x06~0xFE:Reserved
0xFF: Invalid 
*/

  if(Diag_u8OutSideAirQuanlityStatus <= 0x05U)
  {
    pMsgContext->resData[0] = Diag_u8OutSideAirQuanlityStatus;
  }
  else
  {
    pMsgContext->resData[0] = 0xFFU;    
  }
  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 1;
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescReadOutSideAirQuanlityValue (Service request header:$22 $63 $18 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadOutSideAirQuanlityValue(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */
  pMsgContext->resData[0] = (Diag_u16OutSideAirQuanlityValue>>8U);
  pMsgContext->resData[1] = (uint8)(Diag_u16OutSideAirQuanlityValue);

  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 2;
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescReadAQSVoltage (Service request header:$22 $63 $19 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadAQSVoltage(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */
  pMsgContext->resData[0] = (uint8)(Diag_u16AQSAdvalue>>8U);
  pMsgContext->resData[1] = (uint8)(Diag_u16AQSAdvalue);
  
  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 2;
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescReadCoolantTemperature (Service request header:$22 $63 $1A )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadCoolantTemperature(DescMsgContext* pMsgContext)
{
    
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */

  if(Diag_u16CoolantTempValid == 0)/*Valid*/
  {
      pMsgContext->resData[0] = Diag_u16CoolantTemp;
  }
  else
  {
      pMsgContext->resData[0] = 0xFF;
  }

  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 1;
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescReadTelltalePWMDutyControl (Service request header:$22 $63 $1C )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadTelltalePWMDutyControl(DescMsgContext* pMsgContext)
{
  uint16 u16PWMDuty;
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */
#if 0
  u16PWMDuty = Diag_u16TelltalePWMDuty1+Diag_u16TelltalePWMDuty2+Diag_u16TelltalePWMDuty3;
  
  pMsgContext->resData[0] = (uint8)(u16PWMDuty/3);
  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 1;
  #endif
  DescSetNegResponse(kDescNrcRequestOutOfRange);
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescReadECUSupplierVoltage (Service request header:$22 $DF $0 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadECUSupplierVoltage(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */
  pMsgContext->resData[0] = Diag_u16BatteyVoltage;
  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 1;
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescReadKL15status (Service request header:$22 $DF $3 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadKL15status(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */

  /*As the Diag called in the Mian, so the KL15 will always be on*/
  
  pMsgContext->resData[0] = On;
  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 1;
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescReadBackup_configuration_information (Service request header:$22 $DF $EF )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadBackup_configuration_information(DescMsgContext* pMsgContext)
{
    uint16 u16i;
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Dummy example how to access the request data. */
  /* Assumming the FIRST DATA byte contains important data which has to be less than a constant value. */

  for(u16i = 0U; u16i < Diag_nBackupCfgInfor_len; u16i++)
  {
       pMsgContext->resData[u16i] = Diag_stLayout.stGroup1.stDiagData.au8BackupCfgInfor[u16i];/*reqData TO resData,by zsc,160521*/
  }
  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 64;
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescReadECUFunctionConfiguration (Service request header:$22 $F1 $1 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadECUFunctionConfiguration(DescMsgContext* pMsgContext)
{
  uint16 u16i;
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Dummy example how to access the request data. */
  /* Assumming the FIRST DATA byte contains important data which has to be less than a constant value. */

  for(u16i = 0U; u16i < Diag_nFunctionCfg_Len; u16i++)
  {
       pMsgContext->resData[u16i] = Diag_stLayout.stGroup1.stDiagData.au8FunctionCfg[u16i];/*reqData TO resData,by zsc,160521*/
  }
  /* User service processing finished. */
  //DescProcessingDone();/*delete by zsc,160521*/
  pMsgContext->resDataLen = 4;/*add by zsc,160521*/
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescReadVehicleNetworkConfigurationDataIdentifier (Service request header:$22 $F1 $10 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadVehicleNetworkConfigurationDataIdentifier(DescMsgContext* pMsgContext)
{
  uint16 u16i;
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Dummy example how to access the request data. */
  /* Assumming the FIRST DATA byte contains important data which has to be less than a constant value. */

  for(u16i = 0U; u16i < Diag_nVehicleNetworkConfiguration_Len; u16i++)
  {
       pMsgContext->resData[u16i] = Diag_stLayout.stGroup1.stDiagData.au8VehicleNetworkConfiguration[u16i];/*reqData TO resData,by zsc,160521*/
  }
  pMsgContext->resDataLen = 8;
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescReadVehicle_Name (Service request header:$22 $F1 $12 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadVehicle_Name(DescMsgContext* pMsgContext)
{
    uint16 u16i;
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Dummy example how to access the request data. */
  /* Assumming the FIRST DATA byte contains important data which has to be less than a constant value. */

  for(u16i = 0U; u16i < Diag_nVehicleName_Len; u16i++)
  {
       pMsgContext->resData[u16i] = Diag_stLayout.stGroup1.stDiagData.au8VehicleName[u16i];/*reqData TO resData,by zsc,160521*/
  }
  pMsgContext->resDataLen = 8;/*add by zsc,160521*/
  /* User service processing finished. */
  DescProcessingDone();
}

/*  ********************************************************************************
 * Function name:ApplDescReadDiagnosticVersion (Service request header:$22 $F1 $13 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadDiagnosticVersion(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */

  /*Geely SPEC is V3.2*/
  pMsgContext->resData[0] = 0x03;
  pMsgContext->resData[1] = 0x02;
  pMsgContext->resData[2] = g_descMainVersion;
  pMsgContext->resData[3] = g_descSubVersion;
  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 4;
  /* User service processing finished. */
  DescProcessingDone();
}

/*  ********************************************************************************
 * Function name:ApplDescReadBootSoftwareIdentification (Service request header:$22 $F1 $80 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadBootSoftwareIdentification(DescMsgContext* pMsgContext)
{
  uint8* u8BootSoftwareAddr;
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */
  u8BootSoftwareAddr = &BootSoftwareIdentification;
  memcpy(&pMsgContext->resData[0],u8BootSoftwareAddr,BootSoftwareIdentificationLen);
  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 16;
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescReadActiveDiagnosticSession (Service request header:$22 $F1 $86 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadActiveDiagnosticSession(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */
  
  //pMsgContext->resData[0] = DescGetStateSession();
   uint8 u8SessionValue=DescGetStateSession();
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */
  if(u8SessionValue==kDescStateSessionDefault) /*by zsc,160521*/
  {
  	pMsgContext->resData[0] = 1;
  }
  else if(u8SessionValue==kDescStateSessionProgramming)
  {
  	pMsgContext->resData[0] = 2;
  }
  else if(u8SessionValue==kDescStateSessionExtendedDiagnostic)
  {
  	pMsgContext->resData[0] = 3;
  }
  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 1;
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescReadGeelySparePartNumber (Service request header:$22 $F1 $87 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadGeelySparePartNumber(DescMsgContext* pMsgContext)
{
  uint8* u8GeelySparePartNumAddr;
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */
#if 0
  for(u8i=0U;u8i<Diag_GeelySparePartNumber_Len;u8i++)
  {
    pMsgContext->resData[u8i] = Diag_GeelySparePartNumber[u8i];
  }  
  pMsgContext->resData[8] = 0x20U;/*Modify by LT,20160806*/
  pMsgContext->resData[9] = 0x20U;
#endif

  u8GeelySparePartNumAddr = &GeelySparePartNumber;
  memcpy(&pMsgContext->resData[0],u8GeelySparePartNumAddr,16u);
  
  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 10;
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescReadVehicleManufacturerECUSoftwareVersionNumber (Service request header:$22 $F1 $89 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadVehicleManufacturerECUSoftwareVersionNumber(DescMsgContext* pMsgContext)
{
  uint8 u8i;
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */

  pMsgContext->resData[0] = VehicleManufacturerECUSWVerNum[0];
  pMsgContext->resData[1] = VehicleManufacturerECUSWVerNum[1];
  pMsgContext->resData[2] = VehicleManufacturerECUSWVerNum[2];

  for(u8i = 3; u8i<16; u8i++)
  {
    pMsgContext->resData[u8i] = 0x20U;
  }
  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 16;
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescReadSystemSupplierIdentifier (Service request header:$22 $F1 $8A )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadSystemSupplierIdentifier(DescMsgContext* pMsgContext)
{
  uint8 u8i;
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */

  for(u8i=0U;u8i<Diag_SystemSupplier_Len;u8i++)
  {
    pMsgContext->resData[u8i] = Diag_SystemSupplier[u8i];
  }  
  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 6; /*change to 6, by zsc,160521*/

  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescReadECUManufacturingDate (Service request header:$22 $F1 $8B )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadECUManufacturingDate(DescMsgContext* pMsgContext)
{
  uint16 u16i;
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Dummy example how to access the request data. */
  /* Assumming the FIRST DATA byte contains important data which has to be less than a constant value. */

  for(u16i = 0U; u16i < Diag_nECUManufacturingDate_Len; u16i++)
  {
       pMsgContext->resData[u16i] = Diag_stLayout.stGroup1.stDiagData.au8ECUManufacturingDate[u16i];/*reqData TO resData,by zsc,160521*/
  }
  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 4;
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescReadECUSerialNumber (Service request header:$22 $F1 $8C )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadECUSerialNumber(DescMsgContext* pMsgContext)
{
    uint16 u16i;
    uint8* u8GeelySparePartNumAddr;
    uint8 u8Year,u8Month,u8Day;
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Dummy example how to access the request data. */
  /* Assumming the FIRST DATA byte contains important data which has to be less than a constant value. */

   /*Copy the suppilerNum,byte1~byte5*/    
   for(u16i = 0U; u16i < Diag_SystemSupplier_Len; u16i++)
   {
       pMsgContext->resData[u16i] = Diag_SystemSupplier[u16i];
   }
    
   /*Copy the PartNum,byte6~byte15,for KC-2,KC-2HB,Partnum only 8 byte,need fill with "0"*/
   
   pMsgContext->resData[6]='0';
   pMsgContext->resData[7]='0';
   u8GeelySparePartNumAddr = &GeelySparePartNumber;
   memcpy(&pMsgContext->resData[8],u8GeelySparePartNumAddr,10u);

  /*Copy the Date,byte16~byte18*/
  /*Set accroding to the 0xF18C Geely define-20161121*/
   u8Year = (Diag_au8Group1ECUManufacturingDate[1]>>4)*10+(Diag_au8Group1ECUManufacturingDate[1]&0x0FU);/*Change to BCD*/
   u8Month = (Diag_au8Group1ECUManufacturingDate[2]>>4)*10+(Diag_au8Group1ECUManufacturingDate[2]&0x0FU);/*Change to BCD*/
   u8Day = (Diag_au8Group1ECUManufacturingDate[3]>>4)*10+(Diag_au8Group1ECUManufacturingDate[3]&0x0FU);/*Change to BCD*/
   
   u8Year =  (u8Year-1u)%30;
   u8Month = (u8Month-1u)%12;
   u8Day =   (u8Day-1u)%31;
   pMsgContext->resData[18] = Geely_u8DateTable[u8Year];
   pMsgContext->resData[19] = Geely_u8DateTable[u8Month];
   pMsgContext->resData[20] = Geely_u8DateTable[u8Day];

  for(u16i = 0U; u16i < 5U; u16i++)
  {
       pMsgContext->resData[21+u16i] = Diag_stLayout.stGroup1.stDiagData.au8ECUSerialNumber[u16i];/*reqData TO resData,by zsc,160521*/
  }

  pMsgContext->resDataLen = 24U;
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescReadVehicleIdentificationNumber (Service request header:$22 $F1 $90 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadVehicleIdentificationNumber(DescMsgContext* pMsgContext)
{
    uint16 u16i;
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Dummy example how to access the request data. */
  /* Assumming the FIRST DATA byte contains important data which has to be less than a constant value. */

  for(u16i = 0U; u16i < Diag_nvehicleIdentificationNumber_Len; u16i++)
  {
       pMsgContext->resData[u16i] = Diag_stLayout.stGroup1.stDiagData.au8vehicleIdentificationNumber[u16i];/*reqData TO resData,by zsc,160521*/
  }
  pMsgContext->resDataLen = 17u; /*by zsc,160521*/
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescReadsystemSupplierECUHardwareVersionNumber (Service request header:$22 $F1 $93 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadsystemSupplierECUHardwareVersionNumber(DescMsgContext* pMsgContext)
{
  uint8 u8Ret,u8i,u8Array[16];
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */  
#if 0
  for(u16i = 0U; u16i < 5U; u16i++)
  {
        pMsgContext->resData[0] ='A'+(HW_VERSION_INTERNAL>>12);/* Diag_stRomLayout.stGroup2.stDiagBuffer.au8SystemSupplierECUSWVerNum[u8i];*/
        pMsgContext->resData[1] ='0'+((HW_VERSION_INTERNAL>>8)&0x0FU);
        pMsgContext->resData[2] ='.';
        pMsgContext->resData[3] ='0'+((HW_VERSION_INTERNAL&0xFF)/10);
        pMsgContext->resData[4] ='0'+((HW_VERSION_INTERNAL&0xFF)%10);
   } 
#endif

  u8Ret = Diag_u8ReadEEDData(ECUHardwareNumberAddr,&u8Array[0],ECUHardwareNumberLen);
   
  if(u8Ret == 0u)
  {  
    pMsgContext->resData[0] = (u8Array[0]>>4u)+'0';
    pMsgContext->resData[1] = (u8Array[0]&0x0Fu)+'0';   
    
    for(u8i = 2u; u8i < 16u; u8i++)
    {
        pMsgContext->resData[u8i] = 0x20u;
    }   
  }
  else
  {
    pMsgContext->resData[0] = ((HW_VERSION_INTERNAL>>4u)&0x0F)+'0';
    pMsgContext->resData[1] = (HW_VERSION_INTERNAL&0x0Fu)+'0';   
    
    for(u8i = 2u; u8i < 16u; u8i++)
    {
        pMsgContext->resData[u8i] = 0x20u;
    }    
  }
  
  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 16U;
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescReadsystemSupplierECUSoftwareVersionNumber (Service request header:$22 $F1 $95 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadsystemSupplierECUSoftwareVersionNumber(DescMsgContext* pMsgContext)
{
  uint16 u16i;
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */  

  for(u16i = 0U; u16i < 5U; u16i++)
  {
        pMsgContext->resData[0] ='A'+(SW_VERSION_INTERNAL>>12);/* Diag_stRomLayout.stGroup2.stDiagBuffer.au8SystemSupplierECUSWVerNum[u8i];*/
        pMsgContext->resData[1] ='0'+((SW_VERSION_INTERNAL>>8)&0x0FU);
        pMsgContext->resData[2] ='.';
        pMsgContext->resData[3] ='0'+((SW_VERSION_INTERNAL&0xFF)/10);
        pMsgContext->resData[4] ='0'+((SW_VERSION_INTERNAL&0xFF)%10);
   } 
  
   for(u16i = 5U; u16i<16U; u16i++)
   {
        pMsgContext->resData[u16i] = 0x20U;
   }
  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 16U;
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescReadSystemNameOrEngineType (Service request header:$22 $F1 $97 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadSystemNameOrEngineType(DescMsgContext* pMsgContext)
{
    uint16 u16i;
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Dummy example how to access the request data. */
  /* Assumming the FIRST DATA byte contains important data which has to be less than a constant value. */

  for(u16i = 0U; u16i < Diag_nSystemNameOrEngineType_Len; u16i++)
  {
       pMsgContext->resData[u16i] = Diag_stLayout.stGroup1.stDiagData.au8SystemNameOrEngineType[u16i];/*reqData TO resData,by zsc,160521*/
  }
  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 8U;/*by zsc,160521*/
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescReadRepairShopCodeOrTesterSerialNumber (Service request header:$22 $F1 $98 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadRepairShopCodeOrTesterSerialNumber(DescMsgContext* pMsgContext)
{
 #if 0
    uint16 u16i;
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Dummy example how to access the request data. */
  /* Assumming the FIRST DATA byte contains important data which has to be less than a constant value. */

  for(u16i = 0U; u16i < Diag_nRepairShopCodeOrTesterSerialNumber_Len; u16i++)
  {
       pMsgContext->resData[u16i] = Diag_stLayout.stGroup1.stDiagData.au8RepairShopCodeOrTesterSerialNumber[u16i];/*reqData TO resData,by zsc,160521*/
  }
  #endif

  uint8 u8Ret,u8i;
  
  u8Ret = Diag_u8ReadEEDData(RepairShopCodeOrTesterSNAddr,&pMsgContext->resData[0],RepairShopCodeOrTesterSNLen);  

  if(u8Ret!=0u)
  {
    for(u8i = 0u; u8i<16u; u8i++)
    {
        pMsgContext->resData[u8i] = 0x20u;
    }
  }
   /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 16U;/*by zsc,160521*/
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescReadProgrammingOrConfigurationDate (Service request header:$22 $F1 $99 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadProgrammingOrConfigurationDate(DescMsgContext* pMsgContext)
{
  #if 0
    uint16 u16i;
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Dummy example how to access the request data. */
  /* Assumming the FIRST DATA byte contains important data which has to be less than a constant value. */

  for(u16i = 0U; u16i < Diag_nProgrammingOrConfigurationDate_Len; u16i++)
  {
       pMsgContext->resData[u16i] = Diag_stLayout.stGroup1.stDiagData.au8ProgrammingOrConfigurationDate[u16i];/*reqData TO resData,by zsc,160521*/
  }
  #endif

  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */
  
  uint8 u8Ret;

  u8Ret = Diag_u8ReadEEDData(ProgrammingOrConfigurationDateAddr,&pMsgContext->resData[0],ProgrammingOrConfigurationDateLen); 
  
  if(u8Ret!=0u)
  {

     pMsgContext->resData[0] = 0x20u;
     pMsgContext->resData[1] = 0x00u;
     pMsgContext->resData[2] = 0x01u;
     pMsgContext->resData[3] = 0x01u;

  }  
    /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 4U;/*by zsc,160521*/
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescReadECUInstallationDateDataIdentifier (Service request header:$22 $F1 $9D )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadECUInstallationDateDataIdentifier(DescMsgContext* pMsgContext)
{
    uint16 u16i;
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Dummy example how to access the request data. */
  /* Assumming the FIRST DATA byte contains important data which has to be less than a constant value. */

  for(u16i = 0U; u16i < Diag_nECUInstallationDateDataIdentifier_Len; u16i++)
  {
       pMsgContext->resData[u16i] = Diag_stLayout.stGroup1.stDiagData.au8ECUInstallationDateDataIdentifier[u16i];/*reqData TO resData,by zsc,160521*/
  }
     /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 4U;/*by zsc,160521*/
  /* User service processing finished. */
  DescProcessingDone();
}


#if defined (DESC_ENABLE_MULTI_CFG_SUPPORT)
/* ********************************************************************************
 * Function name:ApplDescIsDataIdSupported
 * Description: Additionaly reject a supported PID (multi ECU configuration)
 * Returns:  kDescTrue - if still supported, kDescFalse - if not supported
 * Parameter(s):The PID number
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ******************************************************************************** */
DescBool ApplDescIsDataIdSupported(vuint16 pid)
{
  return kDescTrue;
}
#endif

void ASCII2HexCopy(uint8 data, uint8 *pBuf)
{
    pBuf[0] = Ascii2Hex(data);
}
/**********************************************************************
------------------------------- ver change ----------------------------*/
void VerChange(uint8 VerNum,DescMsgContext* pMsgTemp)
{
#if 0
	uint8 VerTempSave[2];
	/*--first byte---*/
	u8VerTemp[0]=(VerNum&0xf0)>>4;
	u8VerTemp[0]=((u8VerTemp[0]>>2)+0x0a);	
	ASCII2HexCopy(u8VerTemp[0],&VerTempSave[0]);
	pMsgTemp->resData[0]=VerTempSave[0];
	
	/*--second byte---*/
	u8VerTemp[1]=(VerNum&0xf0)>>4;
	//u8VerTemp[1]=((u8VerTemp[0]>>2)+0x0a);
	u8VerTemp[1]%=4;
	ASCII2HexCopy(u8VerTemp[1],&VerTempSave[0]);
	pMsgTemp->resData[1]=VerTempSave[0];
	
	/*--Third byte---*/
	pMsgTemp->resData[2]=0x2e;
	
	/*--four byte---*/
	u8VerTemp[3]=(VerNum&0x0f);
	ASCII2HexCopy(u8VerTemp[3],&VerTempSave[0]);
	pMsgTemp->resData[3]=VerTempSave[0];
#endif
}

/*------------------------------- check if bcd ----------------------------*/
 uint8 CheckIfBcd(uint8 *Tempdata)
{
	uint8 SaveTemp=*Tempdata;
	if(((SaveTemp&0x0F)>=0x0A)||((SaveTemp&0xF0)>=0xA0))
	{
		return False;
	}
	else
	{
		return True;
	}
}

/***********************************************************************
------------------------------- hex to bcd ----------------------------*/
 uint8 Hex2Bcd(uint8 *Tempdata)
{
	uint8 SaveTemph;
	uint8 SaveTempl;
	SaveTemph=*Tempdata/10;
	SaveTempl=*Tempdata%10;
	return((SaveTemph<<4)+SaveTempl);	
}

/***********************************************************************
------------------------------- bcd to hex ----------------------------*/
 uint8 Bcd2Hex(uint8* Tempdata)   //10 TO 16
{
	uint8 SaveTemph;
	uint8 SaveTempl;
	SaveTemph=(*Tempdata>>4)*10;
	SaveTempl=(*Tempdata&0x0f);
	return((SaveTemph+SaveTempl));	
}


#define AppTempFactor (10)
#define AppTempOffset (40)
#define DiagTempFactor (2)
#define DiagTempOffset (40)

static vuint8 ApplDescAppToDiagTempFormat(vuint16 u16AppTemp)
{

    /*************************************
    AppData/AppFactor-AppOffset= DiagData/Factor-Offset2= Temp
    ************************************/    
   vuint16 u16DiagTemp;
    /*Calculate the actual Temp*/
   u16DiagTemp = ((u16AppTemp+AppTempOffset*AppTempFactor)-AppTempFactor*DiagTempOffset)/5;

   /*The max temperature is 87C*/ 
   if(u16DiagTemp>0xFE)
   {
        u16DiagTemp = 0xFE;
   }
   return (uint8)(u16DiagTemp);
}


Std_ReturnType DIAG_NetWorkCf(uint8* Res)
{
   uint8  u8i;
    
   for(u8i=0;u8i<8;u8i++) 
   {
        Res[u8i] = Diag_stLayout.stGroup1.stDiagData.au8VehicleNetworkConfiguration[u8i];
   }

   return 0;
}

Std_ReturnType DIAG_FunctionCf(uint8* Res)
{
   uint8  u8i;
    
   for(u8i=0;u8i<4;u8i++) 
   {
        Res[u8i] = Diag_stLayout.stGroup1.stDiagData.au8FunctionCfg[u8i];
   }

   return 0;
}
uint8 DIAG_u8GetValue( DIAG_tenu8VarNumber enIndex )
{
 	if ( enIndex < DIAG_nu8Max )
	{
		return DIAG_au8Array[enIndex];
	}
	else
	{
		return DIAG_au8Array[DIAG_nu8Max-1];
	}   
}
